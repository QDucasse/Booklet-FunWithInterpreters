!! Implementing a Structural Evaluator

An evaluator is kind of interpreter that executes a program. For example a Pharo evaluator is an interpreter that takes as input a Pharo program and executes each of the statements of such input program, returning finally the result of the execution. In this and the following chapters we will implement a Pharo evaluator as an AST interpreter, using the visitor pattern we have seen before, meaning that the input of our evaluator will be AST nodes of a program to evaluate.

For presentation purposes, we will develop the evaluator in several stages, each in a different chapter.
First, in this chapter, we will show how to implement a structural evaluator, i.e., an evaluator that reads and writes the structures of objects, starting the presentation from constant values.
Later chapters will incrementally add support for other language features that deserve a chapter for themselves such as messages and blocks.

The presentation of this chapter is done in a somehow-relaxed TDD (test driven development) style.
For each new feature we first define the scenario we want to cover. Since we are developing an evaluator, each scenario will be some code to execute and an expected result. We then define a test for the scenario and we make it pass. Before going to the next scenario, we do some refactorings to enhance the quality of our code.

During this process we will define and refine an AST visitor.
Note that we will write the visitor from scratch but we will reuse the node of the Pharo AST and their functionalities.

!!! Setting Up the Stage

To start writing our Pharo evaluator in TDD style, we will start by creating out test class ==CHInterpreterTest==.

[[[
TestCase subclass: #CHInterpreterTest
	instanceVariableNames: ''
	classVariableNames: ''
	package: 'Champollion-Core'
]]]

This class will, until a change is imperative, host all our test methods.

!!!! Preparing the Scenarii

Our scenarios, made out of classes and methods to be interpreted, need to be written somewhere too.
We could store those scenarios in strings in our test class, that we will then need to parse and give to our interpreter as input. However, for simplicity, and because in this book we do not want to center ourselves in parsing issues, we will write our scenarii as normal Pharo code, in normal Pharo classes. This solution is simple enough and versatile to support more complex situations in the future.

We will host our first scenarios as methods in a new class named ==CHInterpretable==.

[[[
Object subclass: #CHInterpretable
	instanceVariableNames: ''
	classVariableNames: ''
	package: 'Champollion'
]]]


!!! Scenario: A Method Returning an Integer

Our first scenario is a method returning an integer, as in the code below:

[[[
CHInterpretable >> returnInteger [
	^ 5
]
]]]

Executing such a method should return an integer with value 5.

!!!! Writing a Red Test

Our first test will implement what our scenario defined above: executing our method should return 5.
This first test specifies not only part of the behaviour of our interpreter, but also helps us in defining the part of its API: we want our interpreter to be able to start executing starting from some method's AST.
Below we define a first test for it: ==testReturnInteger==.

[[[
CHInterpreterTest >> testReturnInteger
	| ast result |
	ast := (CHInterpretable >> #returnInteger) ast.
	result := self interpreter execute: ast. 
	self assert: result equals: 5
]]]

Our first test is worth one comment: since our evaluator is an AST interpreter, it requires an AST as input.
In other words, we need to get the AST of the ==returnInteger== method.
Instead of invoking the parser to get an AST from source code, we will use Pharo's reflective API to get the AST of an already existing method.

!!!! Making the test pass: a First Constant Evaluator

Executing our first test will fail first because our test does not understand ==interpreter==, meaning we need to implement a method for it in our test class. We implement it as a factory method in our test class, returning a new instance of ==CHInterpreter==, and we define the class ==CHInterpreter== as follows.

[[[
CHInterpreterTest >> interpreter [
	^ CHInterpreter new
]

Object subclass: #CHInterpreter
	instanceVariableNames: ''
	classVariableNames: ''
	package: 'Champollion'
]]]

The class ==CHInterpreter== will be the main entry point for our evaluator, and it will implement a visitor pattern over the Pharo method ASTs.  Note that we do not inherit from the default Pharo AST Visitor. The Pharo AST visitor implements already generic versions of the ==visitXXX:=== methods that will do nothing instead of failing. Not inheriting from it allows us to get problems as does not understand exceptions that we will implement step by step in the debugger. We nevertheless follow the same API as the default AST visitor and we use the nodes' ==accept:== visiting methods.

At this point, re-executing the test fails with a new error: our ==CHInterpreter== instance does not understand the message ==execute:==. We imeplement ==execute:== to call the visitor main entry point, i.e., the method ==visitNode:==.

[[[
CHInterpreter >> execute: anAST [
	^ self visitNode: anAST
]
]]]

[[[
CHInterpreter >> visitNode: aNode [
	^ aNode acceptVisitor: self
]
]]]

Since the AST we will evaluate is the AST of a method, restarting the test the execution halts because of the missing ==visitMethodNode:==. A first implementation for this method simply continues the visit on the body of the method.

[[[
CHInterpreter >> visitMethodNode: aMethodNode [
	^ self visitNode: aMethodNode body
]
]]]

Execution then arrives to a missing ==visitSequenceNode:==. Indeed, the body of a method is a sequence node containing a list of temporary variable definitions and a list of statements. Since our scenario has only a single statement with no temporary variables, a first version of ==visitSequenceNode:== ignores temporary declarations and handles all the statements paying attention that the last statement value should be returned. So we visit all the statements except the last one, and we then visit the last one and return its result. 

[[[
CHInterpreter >> visitSequenceNode: aSequenceNode [
  "Visit all but the last statement without caring about the result"
	aSequenceNode statements allButLast 
		do: [ :each | self visitNode: each ].
  "Return the result of visiting the last statement"
	^ self visitNode: aSequenceNode statements last
]	
]]]

The visitor will then visit the return node, for which we define the ==visitReturnNode:== method.
This method simply visits the contents of the return node (invoking recursively the visitor) and returns the obtained value.

[[[
CHInterpreter >> visitReturnNode: aReturnNode [
	^ self visitNode: aReturnNode value
]
]]]

Finally, the contents of the return node, the integer ==5== is represented as a literal value node.
To handle this node we define the method ==visitLiteralValueNode:== in our visitor.
The implementation just returns the value of the node, which will be the integer we were looking for.

[[[
CHInterpreter >> visitLiteralValueNode: aRBLiteralValueNode [
	^ aRBLiteralValueNode value
]
]]]

Our first test is now green and we are ready to continue our journey.

!!! Scenario: Floats Constants

Our second scenario, since we already have integer constants working, is a method returning a float constant. We can see such scenario in the code below:

[[[
CHInterpretable >> returnFloat [
	^ 3.14
]
]]]

Executing such method should return ==3.14==.

!!!! Writing a Test

Testing this case is straightforward, we should test that evaluating our method should return 5.
We already defined that our interpreter understands the ==execute:==  message, so this test can follow the implementation of our previous test.

[[[
CHInterpreterTest >> testReturnFloat
	| ast result |
	ast := (CHInterpretable >> #returnFloat) ast.
	result := self interpreter execute: ast. 
	self assert: result equals: 3.14
]]]

Two discussions come from writing this test. First, this test is already green, because the case of floating point constants and integer constants exercise the same code, so nothing is to be done on this side. Second, some would argue that this test is somehow repeating code from the previous scenario: we will take care of this during our refactoring step.


!!!! Refactor: Improving the Test Infrastructure

Since we will write many tests with similar structure during this book, it comes handy to share some logic between them. The two tests we wrote so far show a good candidate of logic to share as repeated code we can extract.

The method ==executeSelector:== extracts some common logic that will make our tests easier to read and understand: it obtains the AST of a method from its selector, evaluates it, and returns the value of the  execution.

[[[
CHInterpreterTest >> executeSelector: aSymbol [
	| ast |
	ast := (CHInterpretable >> aSymbol) ast.
	^ self interpreter executeMethod: ast
]
]]]

And we can now proceed to rewrite our first two tests as follows: 

[[[
CHInterpreterTest >> testReturnInteger [

	self 
		assert: (self executeSelection: #returnInteger)
		equals: 5
]
]]]

[[[
CHInterpreterTest >> testReturnFloat [

	self
    assert: (self executeSelector: #returnFloat)
    equals: 3.14
]
]]]

We are ready to efficiently write tests for the other constants. 

!!! Scenario: Boolean Constants

Our final scenario for constants are boolean constants such as ==false== and ==true==.

[[[
CHInterpretable >> returnBoolean [
	^ false
]
]]]

Evaluating such method should return ==false==.

!!!! Writing a test

We define a test for our boolean scenario. Note that here we do not use ==deny:==, because we want to make the result explicit for the reader of the test.

[[[
CHInterpreterTest >> testReturnBoolean [
  "Do not use deny: to make explicit that we expect the value false"
	self
    assert: (self executeSelector: #returnBoolean)
    equals: false
]
]]]


!!! Scenario: Literal Array

We add support for Array. 
First we define some method returning an empty array and a literal array. 

[[[
CHInterpretable >> returnEmptyArray [
	^ #()
]
]]]

[[[
CHInterpretable >> returnLiteralArray [
	^ #(true 1 'ahah')
]
]]]

We add a test to cover case.


[[[
CHInterpreterTest >> testReturnEmptyArray [
	self 
		assert: (self executeSelector: #returnEmptyArray) 
		equals: #()
]
]]]


[[[
CHInterpreterTest >> testReturnLiteralArray [
	self 
		assert: (self executeSelector: #returnLiteralArray) 
		equals: #(true 1 'ahah')
]
]]]

We now have to implement the method ==visitLiteralArrayNode:== to handle arrays.
Here we return the values returned by the interpretation of the elements. 

[[[
CHInterpreter >> visitLiteralArrayNode: aRBLiteralArrayNode [
	^ aRBLiteralArrayNode contents 
			collect: [ :each | self visitNode: each ]
]
]]]

The tests are green.
Up until now we did not consider that any form of variable and we should handle such case.


!!! Handling Self 
The first kind of variable that we handle is ==self== that represents the receiver of the message. 
THe first things we need to do is to make sure that we can specify the receiver of a message


Since we need to have access to the receiver for now we add an instance variable called ==receiver==.
This is a super naive way to handle it since we will need a way to automatically manage receiver and arguments.

[[[
Object subclass: #CHInterpreter
	instanceVariableNames: 'receiver'
	classVariableNames: ''
	package: 'Champollion'
]]]

We define an accessor so that we can easily adapt when we will introduce a better way representation later. 

[[[
CHInterpreter >> receiver [
	^ receiver
]
]]]

We make sure that we can set the receiver when we launch the interpretation and we introduce a new method ==execute:with:== for this. 
We will remove 

[[[
CHInterpreter >> execute: anAST withReceiver: anObject [
	receiver := anObject.
	^ self visitNode: anAST
]
]]]

We redefine the method ==executeSelector:== to use this new method.

[[[
CHInterpreterTest >> executeSelector: aSymbol [
	| ast |
	ast := (CHInterpretable >> aSymbol) ast.
	^ self interpreter executeMethod: ast withReceiver: nil
]
]]]

This way all our tests are still passing and we will be ready to handle the case of ==self== and ==super==.


[[[
CHInterpretable >> returnSelf [
	^ self
]
]]]

[[[
CHInterpreterTest >> testReturnSelf [
	self 
		assert: (self executeSelector: #returnSelf) 
		equals: nil
]
]]]

The interpretation of ==self== is done in the method ==visitSelfNode:==.
It is simple, it just returns the value of the receiver stored in the interpreter.

[[[
CHInterpretable >> visitSelfNode: aRBSelfNode [
	^ self receiver
]
]]]

!!! Handling Super
Following the same logic as for ==self==, we improve the interpreter to support ==super==.

We start by defining a method using ==super== and its companion test. 

[[[
CHInterpretable >> returnSuper [
	^ super
]
]]]

[[[
CHInterpreterTest >> testReturnSuper [
	self 
		assert: (self executeSelector: #returnSuper) 
		equals: nil
]
]]]

What is interesting is that the interpretation of ==super== is that this variable is also the receiver of the message. 
So contrary to a common and wrong believe, ==super== is not the superclass or an instance of the superclass. It is just the receiver.

[[[
CHInterpreter >> visitSuperNode: aRBSelfNode [
	^ self receiver
]
]]]

The logic of the tests is not really satisfactory, so we improve it. 

!!! Improving the Logic of setUp

We want to have a better way to handle receiver in test.
We add an instance variable to the ==CHInterpreterTest== that will hold the receiver.

[[[
TestCase subclass: #CHInterpreterTest
	instanceVariableNames: 'interpreter receiver'
	classVariableNames: ''
	package: 'Champollion'
]]]

In the ==setUp== we assign a new instance to the new instance variable ==receiver==.

[[[
CHInterpreterTest >> setUp [
	super setUp.
	interpreter := self interpreterClass new.
	receiver := CHInterpretable new
]
]]]

We then use the new instance variable in ==executeSelector:==.

[[[
CHInterpreterTest >> executeSelector: aSymbol [
	| ast |
	ast := (CHInterpretable >> aSymbol) ast.
	^ self interpreter executeMethod: ast withReceiver: receiver
]
]]]

We rewrite the test methods ==testReturnSelf== and ==testReturnSuper==.
[[[
CHInterpreterTest >> testReturnSelf [
	self 
		assert: (self executeSelector: #returnSelf) 
		equals: receiver
]
]]]

[[[
CHInterpreterTest >> testReturnSuper [
	self 
		assert: (self executeSelector: #returnSuper) 
		equals: receiver
]
]]]

We are ready to work on more interesting points. 



!!! Receiver State Access

We can work on support instance variable access. 
Let us start with a test.

!!!!! Fixture and Test

We define a getter and setter to be able to control the value put in the instance variable of our instance.

[[[
CHInterpretable >> returnX [
	^ x
]
]]]
 
[[[
CHInterpretable >> x: anInteger [
	x := anInteger
]
]]]

We modify the receiver and when we interpret the accessor we should get the correct value.

[[[
CHInterpreterTest >> testReturnAccessInstanceVariable [
	receiver x: 100.
	self assert: (self executeSelector: #returnX) equals: 100
]
]]]


Our test is failing so we are ready to work.  And now we can define the method ==visitInstanceVariableNode:== to reflectivity access the state of receiver. Note that this implementation does not take into account the fact that an instance variable can be defined in a superclass and still be accessible in the subclass method. 

[[[
CHInterpreter >> visitInstanceVariableNode: aVariableNode [
	^ receiver instVarNamed: aVariableNode name
]	
]]]

Our test should pass!

!!! Receiver State Assignment
We will add support for assignment in receiver's instance variables.

!!!!! Fixture and Tests

We define a method doing an assignment into the instance variable ==x==.
[[[
CHInterpretable >> store100IntoX [
	x := 100
]	
]]]

[[[
CHInterpretable >> x [
	^ x
]
]]]

The test ==testStore100IntoX== launches the interpretation of method ==store100IntoX==.

[[[
CHInterpreterTest >> testStore100IntoX [
	receiver x: 17.
	self executeSelector: #store100IntoX.
	self assert: receiver x equals: 100
]
]]]

!!!!! Implementation

The implementation is straighforward. We define the method ==visitAssignmentNode:==.
Here since we expect to have other variable types in the future we define the storing behavior  (method == store:with:==) of the assigned variable node itself. 

[[[
CHInterpreter >> visitAssignmentNode: anAssignmentNode [
	" x := 100"
	
	| value | 
	value := (self visitNode: anAssignmentNode value).
	anAssignmentNode variable store: value with: self.
	^ value
]
]]]


[[[
RBInstanceVariableNode >> store: anObject with: anInterpreter [
	anInterpreter receiver instVarNamed: name put: anObject
]
]]]

Now our tests should pass. 


!!! Handling Global Variables
We finish this chapter with the handling of global variables such as classes and globals. 
We decided not to use the default Pharo environment so that we have to be more explicit about how to access globals.
It also means that we can control the scope of our interpreter and setting different environments.

We first define the method ==returnGlobal== which accesses and returns the global named ==Global==.

[[[
CHInterpretable >> returnGlobal [
	^ Global
]
]]]

We define a test which specifies that the interpreter' environment has a binding whose key is #Global and value is a new object.

[[[
CHInterpreterTest >> testReturnGlobal [
	| globalObject |
	globalObject := Object new.
	interpreter globalEnvironmentAt: #Global put: globalObject. 
	self assert: (self executeSelector: #returnGlobal) equals: globalObject
]
]]]

We introduce a new instance variable named ==gloabEnvironment== and we initialize it to a new dictionary.

[[[
Object subclass: #CHInterpreter
	instanceVariableNames: 'stack globalEnvironment'
	classVariableNames: ''
	category: 'Champollion-Core'
]]]

[[[
CHInterpreter >> initialize [
	super initialize. 
	stack := CTStack new.
	globalEnvironment := Dictionary new
]
]]]

We add ==globalEnvironmentAt:put:== to add a new binding to the environment.
[[[
CHInterpreter >> globalEnvironmentAt: aSymbol put: anObject [
	globalEnvironment at: aSymbol put: anObject
]
]]]

Finally we simply define a new method ==visitGlobalNode:== that will return the value of a global node
by returning the value associated with the key in the global environment.

[[[
CHInterpreter >> visitGlobalNode: aRBGlobalNode [
	^ self globalEnvironment at: aRBGlobalNode name 
		ifAbsent: [ self error: aRBGlobalNode name, ' not found' ]
]
]]]


!!! Conclusion
This interpreter is basic. It does not cover arguments, temporaries or messages. 
This is what we will cover in the following chapter.
Then we will cover blocks and their specific semantics in subsequent chapters.

