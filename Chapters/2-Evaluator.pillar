!! A First Interpreter: An Simple Evaluator

In this chapter we will develop step by step a Pharo program interprerter.
We will incrementally add support for language characteristics.
Here is the progression: returning constants, accessing receiver state, instance variable assignment, 
simple temporaries, self messages, ....

For each of the steps we will start by defining a method illustrating the situation, then we define a test and 
we implement the features. 

Doing so we will define and refine a visitor. 
Note that we will write the visitor from scratch but we will reuse the node of the Pharo AST and their  
functionalities.

!!! Setting the stage

The tests that we will define will be hosted in the class ==BasicInterpreterTest==.
[[[
TestCase subclass: #BasicInterpreterTest
	instanceVariableNames: ''
	classVariableNames: ''
	package: 'Champollion'
]]]

The class ==Interpretable== is a class hosting methods that we will execute. 

[[[
Object subclass: #Interpretable
	instanceVariableNames: ''
	classVariableNames: ''
	package: 'Champollion'
]]]

Here we define the first method that we would like to execute: the method ==returnFive==

[[[
Interpretable >> returnFive

	^ 5
]]]

Our first test is worth one comment: we access the AST of the method that we want to execute
then we instantiate our interpreter and ask it to execute the ast. 
And we check that we get the expected result. 

[[[
BasicInterpreterTest >> testReturnConstant

	| ast result |
	ast := (Interpretable >> #returnFive) ast.
	result := self interpreter execute: ast. 
	self assert: result equals: 5
]]]

We define two helper methods: ==interpreter== and ==interpreterClass== as follows: 

[[[
BasicInterpreterTest >> interpreterClass 

	^ BasicInterpreter
]]]

[[[
BasicInterpreterTest >> interpreter

	^ self interpreterClass new
]]]



!!! Building a minimal constant evaluator

Now we are ready to define our interpreter:

[[[
Object subclass: #BasicInterpreter
	instanceVariableNames: ''
	classVariableNames: ''
	package: 'Champollion'
]]]

The method ==execute:== simply call the visitor main entry point. 

[[[
BasicInterpreter >> execute: anAST

	^ self visitNode: anAST
]]]

[[[
BasicInterpreter >> visitNode: aNode
	^ aNode acceptVisitor: self
]]]

The first visitor method of interest is the method ==visitMethodNode:==
It just dispatches on ==visitMethodBodyNode:==.
[[[
BasicInterpreter >> visitMethodNode: aMethodNode

	^ self visitMethodBodyNode: aMethodNode body
]]]

For now ==visitMethodBodyNode:== just visit the method body (an ==RBSequenceNode==).
[[[
BasicInterpreter >> visitMethodBodyNode: aMethodBodyNode
	^ self visitNode: aMethodBodyNode 
]]]

The first version of ==visitSequenceNode:== ignore possible temporary declarations and 
handle all the statements paying attention that the last statement value should be returned.

[[[
BasicInterpreter >> visitSequenceNode: aSequenceNode
	
	aSequenceNode statements allButLast do: [ :each | self visitNode: each ].
	^ self visitNode: aSequenceNode statements last.
]]]


Since we want to be able to access return value we define the ==visitReturnNode:== to handle 
[[[
BasicInterpreter >> visitReturnNode: aReturnNode

	^ self visitNode: aReturnNode value
]]]

For now we only manage literal object such as number, booleans, ...

[[[
BasicInterpreter >> visitLiteralValueNode: aRBLiteralValueNode

	^ aRBLiteralValueNode value
]]]


!!! Accessing receiver state

!!!!! Context and Test
[[[
Interpretable >> returnX

	^ x 
]]]

[[[
BasicInterpreterTest >> testAccessXInInstance

	| ast result |
	ast := (Interpretable >> #returnX) ast.
	result := self interpreter execute: ast with: (Interpretable new x: 100).
	self assert: result equals: 100. 
	
]]]

[[[
Interpretable >> x: anInteger

	x := anInteger
]]]

!!!!!Implementation


[[[
Object subclass: #BasicInterpreter
	instanceVariableNames: 'receiver'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Champollion'
]]]

[[[
BasicInterpreter >> execute: anAST with: anObject

	receiver := anObject.
	^ self visitNode: anAST
]]]


[[[
BasicInterpreter >> visitInstanceVariableNode: aVariableNode

	^ receiver instVarNamed: aVariableNode name
]]]


!!! Instance variable assignment

!!!!! Context and Test
[[[
Interpretable >> store100IntoX

	x := 100.
]]]



[[[
Interpretable >> x

	^ x 
]]]


[[[
BasicInterpreterTest >> testStore100IntoX

	| ast result object  |
	ast := (Interpretable >> #store100IntoX) ast.
	object := Interpretable new. 
	result := self interpreter execute: ast with: object. 
	self assert: object x equals: 100
]]]

!!!!!Implementation

[[[
BasicInterpreter >> visitAssignmentNode: anAssignmentNode
	" x := 100"
	
	| value | 
	value := (self visitNode: anAssignmentNode value).
	anAssignmentNode variable store: value with: self.
	^ value
]]]


[[[
RBInstanceVariableNode >> store: anObject with: anInterpreter 
	
	anInterpreter receiver instVarNamed: name put: anObject
]]]


!!! Temps


[[[
Interpretable >>settingAValueToTemp

	| temp | 
	temp := 10.
	^ temp
]]]

[[[
BasicInterpreterTest >> testSettingAValueToTemp

	| ast result |
	ast := (Interpretable >> #settingAValueToTemp) ast.
	result := self interpreter execute: ast. 
	self assert: result equals: 10 
]]

[[[
BasicInterpreter >> newFrame
	"a new scope is an environment, i.e., a dictionary which supports lookup in its parent.
	This is important to manage variable shadowing. A local temp can hide another temp of a parent
	scope in a local scope."
	
	^ CTEnvironment new
]]]

[[[
BasicInterpreter >> tempAt: aSymbol

	^ frame at: aSymbol
]]]


[[[
BasicInterpreter >> tempAt: aSymbol put: anInteger 

	frame at: aSymbol put: anInteger
]]]
[[[
BasicInterpreter >> visitSequenceNode: aSequenceNode

	self visitTemporaryNodes: aSequenceNode temporaries.
	aSequenceNode statements allButLast do: [ :each | self visitNode: each ].
	^ self visitNode: aSequenceNode statements last.
]]]

[[[
BasicInterpreter >> visitTemporaryNodes: aNodeCollection
	"This is triggered when defining the temporaries between the pipes |a b c|"

	frame := self newFrame. 
	^ aNodeCollection
		do: [ :each | self visitTemporaryDeclarationNode: each ]
]]]

[[[
BasicInterpreter >> visitTemporaryNode: aTemporaryNode

	^ self tempAt: aTemporaryNode name
]]]

[[[
BasicInterpreter >> visitTemporaryDeclarationNode: aTemporaryDeclarationNode
	"| temp |
	temp is a temporary node as we can find in the body of methods."

	self tempAt: aTemporaryDeclarationNode name put: nil.
]]]

!!! More temps tests

[[[
Interpretable >> settingAValueToTempInARow

	| temp1 temp2| 
	temp1 := 10.
	temp2 := temp1.
	^ temp2
]]]

[[[
BasicInterpreterTest >> testSettingAValueToTempInARow
		"settingAValueToTempInARow

			| temp1 temp2| 
			temp1 := 10.
			temp2 := temp1.
			^ temp2
		"
		| ast result |
		ast := (Interpretable >> #settingAValueToTempInARow) ast.
		result := self interpreter execute: ast. 
		self assert: result equals: 10 

]]]


[[[
Interpretable >> settingAValueToTempEmbedded

	| temp1 temp2 | 
	temp2 := temp1 := 10.
	^ temp2
]]]

[[[
BasicInterpreterTest >> testSettingAValueToTempEmbedded
	"settingAValueToTempEmbedded

		| temp1 temp2 | 
		temp2 := temp1 := 10.
		^ temp2
	"
	| ast result |
	ast := (Interpretable >> #settingAValueToTempEmbedded) ast.
	result := self interpreter execute: ast. 
	self assert: result equals: 10 
]]]


!!! self Messages
We will implement now an extremely simple version of message: messages sent to self without arguments. 
The lookup will look only in the class of the receiver. 

!!!!! Context and tests

[[[
BasicInterpreterTest >> testSendMessageReturnX
	"
	sendMessageReturnX
		^ self returnX
	"
	| ast result |
	ast := (Interpretable >> #sendMessageReturnX) ast.
	result := self interpreter execute: ast with: (Interpretable new x: 100).
	self assert: result equals: 100. 
]]]





!!!!! Implementation

The first behavior is to return the receiver as value for the ==self== node. 
Right now we only have one receiver and we will change this when we will support messages to any objects.
[[[
BasicInterpreter >> visitSelfNode: aRBSelfNode 
	^ receiver
]]]

The ==visitMessageNode:== is the core of the Pharo computation. 
We do a bit more than just managing self send messages.
First it computes the message receiver (in the future the receiver may be composed of multiple message).
We look for the method to execute using the message ==lookup:fromClass:==. 

[[[
BasicInterpreter >> visitMessageNode: aMessageNode

	| rec args method | 
	rec := self visitNode: aMessageNode receiver.
	method := self lookup: aMessageNode selector fromClass: rec class.
	^ self execute: method 
]]]

[[[
BasicInterpreter >> lookup: aSymbol fromClass: aClass 
	"return the method ast or nil."
	
	^ (aClass includesSelector: aSymbol)
		ifTrue: [ (aClass compiledMethodAt: aSymbol) ast ]
		ifFalse: [ "no lookup for now" 
					nil ]
]]]



Now we can check that the returning ==self== return the message receiver. 

[[[
BasicInterpreterTest >> testReturnSelf
	"
	returnSelf

		^ self
	"
	| ast result object |
	ast := (Interpretable >> #returnSelf) ast.
	object := (Interpretable new x: 100; yourself).
	result := self interpreter execute: ast with: object.
	self assert: result equals: object 
]]]

!!! Looking in superclass

[[[
BasicInterpreterTest >> testLookupMessageInSuperclass

	| ast result |
	ast := (Interpretable >> #sendMessageReturnX) ast.
	result := self interpreter execute: ast with: (InterpretableSubclass new x: 100).
	self assert: result equals: 100. 
]]]


[[[
BasicInterpreter >> lookup: aSymbol fromClass: aClass 
	"return the method ast or nil."
	
	^ (aClass includesSelector: aSymbol)
		ifTrue: [ (aClass compiledMethodAt: aSymbol) ast ]
		ifFalse: [
			aClass = ProtoObject 
				ifTrue: [ nil ]
				ifFalse: [ self lookup: aSymbol fromClass: aClass superclass ]]
]]]






!!! Sending (self-)messages to other objects

[[[
testNot
	"
	not
		^ false not
	"
	| ast result |
	ast := (Interpretable >> #not) ast.
	result := self interpreter execute: ast.
	self assert: result
]]]




[[[
pushNewFrame
	"Pushing a new scope consists in creating a new dictionary whose parent is the top of the stack
	and pushing it as a new top. This way a variable not found in current scope will be looked up in previous scope."

	| newTop |
	newTop := self newFrame.
	newTop parent: stack top.
	stack push: newTop 
]]]	

[[[
initialize 
	super initialize. 
	stack := Stack new.
	stack push: self newFrame.
]]]

[[[
receiver
	^ stack top at: #self
]]]


Note that the method ==visitMessageNode:== is incomplete because it does not handle arguments and does not pop the stack
once the execution is done. 


[[[
popFrame
	stack pop 
]]]

[[[
visitMessageNode: aMessageNode

	| rec method | 
	self pushNewFrame.
	rec := self visitNode: aMessageNode receiver.
	method := self lookup: aMessageNode selector fromClass: rec class. 
	res := self execute: method.
	self popFrame.
	^ res
]]]	 













!!!!! Another little test
[[[
testIsLiteral
	"
	not

		^ false not
	"
	| ast result |
	ast := (Interpretable >> #isLiteral) ast.
	result := self interpreter execute: ast.
	self assert: result
]]]


!!! Supporting message arguments


[[[
testReturnLastOfAnd
	"
	returnLastOf: a and: b
		^ b
	"
	| ast result |
	ast := (Interpretable >> #returnLastOf:and:) ast.
	result := self interpreter execute: ast withReceiver: Interpretable new andArguments: { 10 . 20}.
	self assert: result equals: 20. 
]]]

[[[
execute: aMethodAST withReceiver: anObject andArguments: args

	self tempAt: #self put: anObject.
	aMethodAST arguments 
		with: args 
		do: [ :arg :value | self tempAt: arg name put: value ].
	^ self visitNode: aMethodAST
]]]



[[[
visitArgumentNode: aRBArgumentNode 
	^ self tempAt: aRBArgumentNode name
]]]

[[[
visitSequenceNode: aSequenceNode
	| res |
	aSequenceNode hasTemporaries
		ifTrue: [ self pushNewFrame 
			self visitTemporaryNodes: aSequenceNode temporaries ].
	aSequenceNode statements allButLast do: [ :each | self visitNode: each ].
	res := self visitNode: aSequenceNode statements last.
	aSequenceNode hasTemporaries
		ifTrue: [ self popFrame ].
	^ res
]]]

[[[
returnLastOf2: b and: a

	^ self returnLastOf: b and: a
]]]

[[[
testReturnLastOfAnd2
	"
	returnLastOf2: b and: a
		^ self returnLastOf: b and: a
	returnLastOf: a and: b
		^ b
		"
	| ast result |
	ast := (Interpretable >> #returnLastOf2:and:) ast.
	result := self interpreter execute: ast withReceiver: Interpretable new andArguments: { 10 . 20}.
	self assert: result  equals: 20. 
]]]


!!! Supporting super

[[[
InterpretableSubclass >> not
	^ super not & false not
]]]

[[[
testSuperNot
	"
	not
		^ super not & false not
	"
	| ast result |
	ast := (InterpretableSubclass >> #not) ast.
	result := self interpreter execute: ast withReceiver: InterpretableSubclass new andArguments: #().
	self assert: result
]]]


[[[
BasicInterpreter >> visitMessageNode: aMessageNode

	| rec args method res | 
	self pushNewFrame.
	rec := self visitNode: aMessageNode receiver.
	args := aMessageNode arguments collect: [ :each | self visitNode: each ].
	method :=  aMessageNode receiver isSuper
		ifTrue: [ self lookup: aMessageNode selector fromClass: rec class superclass ]
		ifFalse: [ self lookup: aMessageNode selector fromClass: rec class ].
	res := self execute: method withReceiver: rec andArguments: args.
	self popFrame.
	^ res 
]]]


[[[
BasicInterpreter >> visitSuperNode: aRBSuperNode 
	^ self receiver
]]]















!!! Sending messages to class


[[[
visitGlobalNode: aRBGlobalNode 

	^ self class environment at: aRBGlobalNode name ifAbsent: [ self error: aRBGlobalNode name, ' not found' ]
]]]







!!! Handling super



!!! Handling arguments


!!! Different receivers 



!!! Nested temporaries and shadowing















