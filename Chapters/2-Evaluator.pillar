!! A First Interpreter: An Simple Evaluator


!!! Setting the stage
[[[
TestCase subclass: #BasicInterpreterTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Champollion'
]]]

[[[
Object subclass: #Interpretable
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Champollion'
]]]

[[[
Interpretable >> returnFive

	^ 5
]]]

[[[
BasicInterpreterTest >> testReturnConstant

	| ast result |
	ast := (Interpretable >> #returnFive) ast.
	result := self interpreter execute: ast. 
	self assert: result equals: 5
]]]


[[[
BasicInterpreterTest >> interpreterClass 

	^ BasicInterpreter
]]]

[[[
BasicInterpreterTest >> interpreter

	^ self interpreterClass new
]]]


!!! Building a minimal constant evaluator

[[[
Object subclass: #BasicInterpreter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Champollion'
]]]

[[[
BasicInterpreter >> execute: anAST

	^ self visitNode: anAST
]]]


[[[
BasicInterpreter >> visitNode: aNode
	^ aNode acceptVisitor: self
]]]

[[[
BasicInterpreter >> visitMethodNode: aMethodNode

	^ self visitMethodBodyNode: aMethodNode body
]]]

[[[
BasicInterpreter >> visitMethodBodyNode: aMethodBodyNode
	^ self visitNode: aMethodBodyNode 
]]]

[[[
BasicInterpreter >> visitSequenceNode: aSequenceNode
	
	aSequenceNode statements allButLast do: [ :each | self visitNode: each ].
	^ self visitNode: aSequenceNode statements last.
]]]


[[[
BasicInterpreter >> visitReturnNode: aReturnNode

	^ self visitNode: aReturnNode value
]]]


[[[
BasicInterpreter >> visitLiteralValueNode: aRBLiteralValueNode

	^ aRBLiteralValueNode value
]]]


!!! Accessing receiver state

!!!!! Context and Test
[[[
Interpretable >> returnX

	^ x 
]]]

[[[
BasicInterpreterTest >> testAccessXInInstance

	| ast result |
	ast := (Interpretable >> #returnX) ast.
	result := self interpreter execute: ast with: (Interpretable new x: 100).
	self assert: result equals: 100. 
	
]]]

[[[
Interpretable >> x: anInteger

	x := anInteger
]]]

!!!!!Implementation


[[[
Object subclass: #BasicInterpreter
	instanceVariableNames: 'receiver'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Champollion'
]]]

[[[
BasicInterpreter >> execute: anAST with: anObject

	receiver := anObject.
	^ self visitNode: anAST
]]]


[[[
BasicInterpreter >> visitInstanceVariableNode: aVariableNode

	^ receiver instVarNamed: aVariableNode name
]]]


!!! Instance variable assignment

!!!!! Context and Test
[[[
Interpretable >> store100IntoX

	x := 100.
]]]



[[[
Interpretable >> x

	^ x 
]]]


[[[
BasicInterpreterTest >> testStore100IntoX

	| ast result object  |
	ast := (Interpretable >> #store100IntoX) ast.
	object := Interpretable new. 
	result := self interpreter execute: ast with: object. 
	self assert: object x equals: 100
]]]

!!!!!Implementation

[[[
BasicInterpreter >> visitAssignmentNode: anAssignmentNode
	" x := 100"
	
	| value | 
	value := (self visitNode: anAssignmentNode value).
	anAssignmentNode variable store: value with: self.
	^ value
]]]


[[[
RBInstanceVariableNode >> store: anObject with: anInterpreter 
	
	anInterpreter receiver instVarNamed: name put: anObject
]]]


!!! Temps


[[[
Interpretable >>settingAValueToTemp

	| temp | 
	temp := 10.
	^ temp
]]]

[[[
BasicInterpreterTest >> testSettingAValueToTemp

	| ast result |
	ast := (Interpretable >> #settingAValueToTemp) ast.
	result := self interpreter execute: ast. 
	self assert: result equals: 10 
]]

[[[
BasicInterpreter >> newFrame
	"a new scope is an environment, i.e., a dictionary which supports lookup in its parent.
	This is important to manage variable shadowing. A local temp can hide another temp of a parent
	scope in a local scope."
	
	^ CTEnvironment new
]]]

[[[
BasicInterpreter >> tempAt: aSymbol

	^ frame at: aSymbol
]]]


[[[
BasicInterpreter >> tempAt: aSymbol put: anInteger 

	frame at: aSymbol put: anInteger
]]]
[[[
BasicInterpreter >> visitSequenceNode: aSequenceNode

	self visitTemporaryNodes: aSequenceNode temporaries.
	aSequenceNode statements allButLast do: [ :each | self visitNode: each ].
	^ self visitNode: aSequenceNode statements last.
]]]

[[[
BasicInterpreter >> visitTemporaryNodes: aNodeCollection
	"This is triggered when defining the temporaries between the pipes |a b c|"

	frame := self newFrame. 
	^ aNodeCollection
		do: [ :each | self visitTemporaryDeclarationNode: each ]
]]]

[[[
BasicInterpreter >> visitTemporaryNode: aTemporaryNode

	^ self tempAt: aTemporaryNode name
]]]

[[[
BasicInterpreter >> visitTemporaryDeclarationNode: aTemporaryDeclarationNode
	"| temp |
	temp is a temporary node as we can find in the body of methods."

	self tempAt: aTemporaryDeclarationNode name put: nil.
]]]

!!! More temps tests

[[[
Interpretable >> settingAValueToTempInARow

	| temp1 temp2| 
	temp1 := 10.
	temp2 := temp1.
	^ temp2
]]]

[[[
BasicInterpreterTest >> testSettingAValueToTempInARow
		"settingAValueToTempInARow

			| temp1 temp2| 
			temp1 := 10.
			temp2 := temp1.
			^ temp2
		"
		| ast result |
		ast := (Interpretable >> #settingAValueToTempInARow) ast.
		result := self interpreter execute: ast. 
		self assert: result equals: 10 

]]]


[[[
Interpretable >> settingAValueToTempEmbedded

	| temp1 temp2 | 
	temp2 := temp1 := 10.
	^ temp2
]]]

[[[
BasicInterpreterTest >> testSettingAValueToTempEmbedded
	"settingAValueToTempEmbedded

		| temp1 temp2 | 
		temp2 := temp1 := 10.
		^ temp2
	"
	| ast result |
	ast := (Interpretable >> #settingAValueToTempEmbedded) ast.
	result := self interpreter execute: ast. 
	self assert: result equals: 10 
]]]

!!! Nested temporaries and shadowing




!!! Different receivers 



!!! Message

!!! Lookup

!!! 














