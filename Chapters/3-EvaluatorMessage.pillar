!! Evaluating Message-sends

In the previous chapter we focused on structural evaluation: reading literal objects and reading and writing values from objects and globals. However, the key abstraction in object-oriented programming and in Pharo in particular are message-sends. The work we did in the previous chapter is nevertheless important to set up the stage: we know have a better taste of the visitor pattern, we started a first testing infrastructure, and eventually message-sends need to carry out some work by using literal objects or reading and writing variables.

In this chapter we will introduce message-sends. Message-sends deserve a chapter on their own because they introduce many different concerns. On the one hand, each message-send is resolved in two steps: first the method-lookup searches in the receiver's hierarchy the method to be executed, and second that method is applied on the receiver. The method-lookup algorithm needs to support normal message-sends as well as `super` message-sends.  On the other hand, each method application needs to set up an execution context to store the receiver, arguments and temporary variables for that method execution. These execution contexts form the execution stack or call-stack. Sending a message pushes a new context in the call-stack, returning from a method pops a context from the call-stack.

!!! Introduction to Stack Management

The way we managed the receiver so far is overly simplistic.
Indeed, each time a program will send a message to another object, we should change the receiver and when the computation ends, the previous receiver should be put back. Moreover, the same happens with method arguments and temporaries. Therefore to introduce the notion of message-send we need a stack. And each element in the stack needs to capture all the execution state require to come back to it later on when a message-send will return. Each element in the call-stack is usually named a stack frame, an activation record, or in Pharo's terminology a context. For the rest of this book we will refer to them as frames, for shortness, and to distinguish them from the reified contexts from Pharo.

A first step to introduce stack management without breaking all our previous tests is to replace the single ==receiver== instance variable with a stack that will be initialized when the evaluator is created. The top of the stack will represent the current execution, and thus we will take the current receiver at each moment from the stack top. Moreover, each time we tell our interpreter to execute something we need to initialize our stack with a single frame.

[[[
"Replace the receiver instance variable by a stack"
Object subclass: #CHInterpreter
	instanceVariableNames: 'stack'
	classVariableNames: ''
	package: 'Champollion-Core'

CHInterpreter >> initialize [
	super initialize. 
	stack := CTStack new.
]
]]]

With this new schema, we can now rewrite the access to the receiver to just access the value of ==#self== of the top frame. 

[[[language=pharo
CHInterpreter >> receiver [
	^ self topFrame at: #self
]

CHInterpreter >> topFrame [
	^ stack top
]
]]]

The final step is to set up a frame when the execution starts, which happened so far in our method ==execute:withReceiver:==. We extend the ==execute:withReceiver:== to create a new frame and define the receiver as ==#self== in the top frames before start the evaluation.

[[[language=pharo
CHInterpreter >> execute: anAST withReceiver: anObject [
	self pushNewFrame.
	self topFrame at: #self  put: anObject.
	^ self visitNode: anAST
]
]]]

The last piece in the puzzle is the method ==pushNewFrame==, which creates a new frame and pushes it on the top of the stack. 
For now, let's represent a frame as a dictionary that will store key-value pairs representing the variables defined in the current method execution: ==self==, and later the arguments and temporaries.

[[[
CHInterpreter >> pushNewFrame [
	| newTop |
	newTop := Dictionary new.
	stack push: newTop.
	^ newTop
]
]]]

This refactor kept all our test green, and opened the path to introduce message-sends.
As the reader may have observed, this stack can only grow.
We will take care of popping frames from the stack later when we revisit method returns.

!!! Evaluating a First Message Send

Let's start as usual by defining a new method exhibiting the scenario we want to work on.
In this case, we want to start by extending our evaluator to correctly evaluate message sends to their return values. Our scenario method ==sendMessageReturnX== does a self message-send and returns the value returned by this message send. On the one hand, we want that in our scenario the receiver of both messages is the same. On the other hand, we want that the message send is correctly evaluated to the return value of the activated method.

Notice that our method ==sendMessageReturnX== and the implementation of the message it sends ==returnX== live in the same class. This means that in this first scenario we can concentrate on the stack management and return value of the message sends, without caring too much about the details of the method lookup algorithm. For this first version we will define a simple and incomplete yet useful method lookup algorithm.

[[[language=pharo
CHInterpretable >> sendMessageReturnX [
	^ self returnX
]
]]]

In our test we want to ensure that in a ==self== message-send, the receiver of both called and callee methods is the same. One way to do that is to mutate the receiver of the first message-send, and access one of its instance variables in the method that is activated by the second message-send.

[[[language=pharo
CHInterpreterTest >> testSelfSend [
	receiver x: 100.
	self 
		assert: (self executeSelector: #sendMessageReturnX) 
		equals: 100
]
]]]

To make this test green, we need to implement the method ==visitMessageNode:==.
Evaluation a message node requires that we recursively evaluate the receiver node, which may be a literal node or a complex expression such as another message-send. From such evaluation we obtain the actual receiver object. Starting from the receiver, we will lookup the method with the same selector as the message-send. In our first implementation we will just fetch the desired method's AST from the receiver's class. Finally, we can activate this method with the receiver using ==execute:withReceiver:== the activation will push a new frame to the call-stack with the given receiver, evaluate the method, and eventually return with a value.

[[[
CHInterpreter >> visitMessageNode: aMessageNode [
	| newReceiver method | 
	newReceiver := self visitNode: aMessageNode receiver.
	method := (newReceiver class compiledMethodAt: aMessageNode selector) ast.
	^ self execute: method withReceiver: newReceiver
]
]]]


!!! Balancing the Stack

We mentioned earlier that when the execution of a method is finished and the execution returns to its caller method, its frame should be also discarded from the stack. The current implementation clearly does not do it.
Indeed, we also said that our initial implementation of the stack only grows, our code never pops frames from the stack.

[[[language=pharo
CHInterpreter >> executeMethod: anAST withReceiver: anObject [
	self pushNewFrame.
	self topFrame at: #self  put: anObject.
	^ self visitNode: anAST
]
]]]

To solve this issue, let us write a test showing the problem first.
The idea of this test is that upon return, the frame of the caller method should be restored and with it its receiver. If we make that the caller and callee methods have different receiver instances, then this test can be expressed as some expression executed after a message-send returns. The following code snippet shows an scenario that fulfills these requirements: it sets an instance variable with some value, sends a message to an object other than ==self== and upon its return it accesses its instance variable again before returning it. Assuming the collaborator object does not modify ==self==, then the result of evaluating this message should be that 1000 is returned.

[[[
CHInterpretable >> setXAndMessage [

		x := 1000.
		collaborator returnX.
		^ x
]
]]]

Our test ==testBalancingStack== executes the message ==setXAndMessage== that should return 1000.

[[[
CHInterpreterTest >> testBalancingStack [

	self
    assert: (self executeSelector: #setXAndMessage)
    equals: 1000
]
]]]

We then finish our set-up by extending ==CHInterpretable== to support delegating to a collaborator object.
We add a ==collaborator== instance variable to the class ==CHInterpretable== with its companion accessors. 
This way we will be able to test that the correct object is set and passed around in the example.

[[[
Object subclass: #CHInterpretable
	instanceVariableNames: 'x collaborator'
	classVariableNames: ''
	package: 'Champollion-Core'

CHInterpretable >> collaborator [
	^ collaborator
]

CHInterpretable >> collaborator: anObject [
	collaborator := anObject
]
]]]

And in the ==setUp== method we give a collaborator to our initial receiver.

[[[
CHInterpreterTest >> setUp [
	super setUp.
	receiver := CHInterpretable new.
	receiver collaborator: CHInterpretable new
]
]]]

!!!! Making the test pass

Executing this test breaks because the access to the instance variable ==x== returns nil, showing the limits of our current implementation.  This is due to the fact that evaluating message send ==returnX== creates a new frame with the collaborator as receiver, and since that frame is not popped from of the stack, when the method returns, the access to the ==x== instance variable accesses the one of the uninitialized collaborator instead of our receiver object.

To solve this problem, we should pop the frame when a method activation finishes. 
This way the stack is balanced. This is what the new implementation of ==executeMethod:withReceiver:==
is doing.

[[[language=pharo
CHInterpreter >> executeMethod: anAST withReceiver: anObject [
	self pushNewFrame.
	self topFrame at: #self  put: anObject.
	result := self visitNode: anAST.
	self popFrame.
	^ result
]

CHInterpreter >> popFrame [
	stack pop
]
]]]

!!!! Ensuring the receiver is correctly set: an Extra Test

Our previous tests did ensure that messages return the correct value, activate the correct methods, and that the stack grows and shrinks. However, we did not ensure yet that the receiver changes correctly on a message send, and since we do not lose any opportunity to strenghten our trust in our implementation with a new 
test, let's write a test for it.

The scenario, illustrated in ==changeCollaboratorX== will ask the collaborator to ==store100IntoX==, implemented previosly. In this scenario, we must ensure that the state of the receiver and the collaborator  are indeed separate and that changing the collaborator will not affect the initial receiver's state.

[[[
CHInterpretable >> changeCollaboratorX [
	collaborator store100IntoX
]
]]]

Our test for this scenario is as follows. If we give some value to the receiver and collaborator, executing our method should change the collaborator but not the initial receiver.

[[[
CHInterpreterTest >> testInstanceVariableStoreInMethodActivationDoesNotChangeSender [
	receiver x: 200.
	collaborator x: 300.

  "changeCollaboratorX will replace collaborator's x but not the receiver's"
	self executeSelector: #changeCollaboratorX.

	self assert: receiver x equals: 200.
	self assert: collaborator x equals: 100
]
]]]

To make our test run, we will store as a convenience the collaborator object in an instance variable of the test too.

[[[
TestCase subclass: #CHInterpreterTest
	instanceVariableNames: 'receiver collaborator'
	classVariableNames: ''
	package: 'Champollion-Tests'

CHInterpreterTest >> setUp [
	super setUp.
	receiver := CHInterpretable new.
  collaborator := CHInterpretable new.
	receiver collaborator: collaborator
]
]]]

This test runs green, meaning that our implementation already covered correctly this case.
We are ready to continue our journey in message-sends.

!!! Supporting Message Arguments

So far we have worked only with unary messages. Unary messages have no arguments, so the number of programs we can express with them only is rather limited. The next step towards having a full-blown interpreter is to support message arguments, which will open us the door to support binary and keyword messages. From the evaluator point of view, as well as from the AST point of view, we will not distinguish between unary, binary and keyword messages. The parser already takes care about distinguishing them and handling their precedence. Indeed, message nodes in the AST are the same for all kind of messages, they have a selector and a collection of argument nodes. Precedence is then modelled as relationships between the AST nodes.


In addition of simply passing the arguments, from an evaluator point of view, we need to care about evaluation order too. This is particularly important because Pharo is an imperative language where messages can trigger side effects. Evaluating two messages in one order may not have the same result as evaluating them in a different order. Arguments in Pharo are evaluated eagerly after evaluating the receiver expression, but before evaluating the message, from left to right. Once all expressions are evaluated, the resulting objects are send as part of the message-send.

!!!! Initial Argument Support

To implement some initial support for arguments, our first scenario is to simply send a message with an argument. For our scenario we already count with one message with an argument: the ==x:== setter. We can then define a method ==changeCollaboratorWithArgument== which uses a it.

[[[language=smalltalk
CHInterpretable >> changeCollaboratorWithArgument [
	collaborator x: 500
]
]]]

In our test, we verify that the method evaluation effectively modifies the collaborator object 
as written in ==changeCollaboratorWithArgument==, and not the initial receiver object.

[[[language=smalltalk
CHInterpreterTest >> testArgumentAccess [

	receiver x: 200.
	collaborator x: 300.

	self executeSelector: #changeCollaboratorWithArgument.

	self assert: receiver x equals: 200.
	self assert: collaborator x equals: 500
]
]]]

Since we have not implemented any support for arguments yet, this test should fail.

Implementing argument support requires two main changes. On the caller side, we need to evaluate the arguments in the context of the caller method and then store those values in the new frame. On the callee side, when an argument access is evaluated, those accesses will not re-evaluate the expressions in the caller. Instead, argument access will just read the variables pre-stored in the current frame.

Let's start by defining the method ==visitArgumentNode:== to implement how a method accesses an argument. We implement this as a look-up in the current frame using the name of the argument.

[[[
CHInterpreter >> visitTemporaryNode: aRBArgumentNode [
	^ self topFrame at: aRBArgumentNode name
]
]]]

Then we need to update ==visitMessageNode:== to compute the arguments by doing a recursive evaluation, and then use those values during the new method activation.

[[[
CHInterpreter >> visitMessageNode: aMessageNode [
	| newReceiver method args |
	args := aMessageNode arguments collect: [ :each | self visitNode: each ].
	newReceiver := self visitNode: aMessageNode receiver.
	method := (newReceiver class compiledMethodAt: aMessageNode selector) ast.
	^ self executeMethod: method withReceiver: newReceiver andArguments: args
]
]]]

To include arguments in the method activation, let's add a new ==arguments== parameter to our method ==execute:withReceiver:== to get ==execute:withReceiver:withArguments:==. 
In addition to add the receiver to the new frame representing the execution, we add a binding for each parameter (called unfornately arguments in Pharo AST) with their corresponding value in the argument collection. We use the message ==with:do:== to iterate both the parameter list and actual arguments as pairs.

[[[
CHInterpreter >> execute: anAST withReceiver: anObject andArguments: aCollection [
	| result |
	self pushNewFrame.
	self tempAt: #self put: anObject.
	anAST arguments with: aCollection
    do: [ :arg :value | self topFrame at: arg name put: value ]. 
	result := self visitNode: anAST.
	self popFrame.
	^ result
]
]]]

Instead of just removing the old ==executeMethod:withReceiver:== method, we redefine it calling the new one with a default empty collection of arguments. This method was used as part of our public API so keeping it will avoid migrating extra code and an empty collection of arguments seems like a sensible and practical default.
 
[[[
CHInterpreter >> executeMethod: anAST withReceiver: anObject [
	 ^ self executeMethod: anAST withReceiver: anObject andArguments: #()
]
]]]

Our tests should all pass now.

!!!! Refactoring the Terrain

Let's now refactor a bit the existing code to clean it up and expose some existing but hidden functionality. Let us extract the code that accesses ==self== and the frame parameters into two other methods that make more intention revealing that we are accessing values in the current frame.

[[[
CHInterpreter >> tempAt: aSymbol [
	^ self topFrame at: aSymbol
]

CHInterpreter >> tempAt: aSymbol put: anInteger [
	self topFrame at: aSymbol put: anInteger
]

CHInterpreter >> execute: anAST withReceiver: anObject andArguments: aCollection [
	| result |
	self pushNewFrame.
	self tempAt: #self put: anObject.
	anAST arguments with: aCollection
    do: [ :arg :value | self tempAt: arg name put: value ]. 
	result := self visitNode: anAST.
	self popFrame.
	^ result
]

CHInterpreter >> receiver [

	^ self tempAt: #self
]

CHInterpreter >> visitTemporaryNode: aRBTemporaryNode [

	^ self tempAt: aRBTemporaryNode name
]
]]]

!!!! Evaluation Order

The last thing we need to make sure is that arguments are evaluated in the correct order.
The evaluation order in Pharo goes as follows: before evaluating a message, the receiver and all arguments are evaluated. The receiver is evaluated before the arguments. Arguments are evaluated in left-to-right order.

Testing the evaluation order in a black-box fashion as we were doing so far is rather challenging with our current evaluator. Indeed, our evaluator does not yet handle arithmetics, allocations nor other kind of primitive. A simple approach to test is to make a counter out of *Peano Axioms>https://en.wikipedia.org/wiki/Peano_axioms*. The main idea is to implement numbers as sets, where the empty set is the zero, the set that contains the zero is one, the set that contains a one is a two, and so on. The only support we need for this is to extend our literal support for dynamic array literals. The code illustrating the idea follows.

[[[
CHInterpretable >> initialize [
  super initialize.
  current := { "empty" }.
]

CHInterpretable >> next [
  | next |
  "Implement a stream as an increment in terms of Peano axioms.
  See https://en.wikipedia.org/wiki/Peano_axioms"
  next := current.
  current := { current }.
  ^ next
]

CHInterpreterTests >> peanoToInt: aPeanoNumber [
  "Helper method to transform a peano number to a normal Pharo integer"
  ^ aPeanoNumber
    ifEmpty: [ 0 ]
    ifNonEmpty: [ 1 + (self peanoToInt: aPeanoNumber first) ]
]
]]]

Using this support, we can express our evaluation order scenario and test as follows.
We will add a new instance variable to ==CHInterpretable== to store its evaluation order.
Then, we are going to send a message with many arguments, evaluating for each argument ==self next==.
The message receiving the many arguments will then receive as argument the three generated peano values, that we will return as dynamic literal array. If evaluation order is right, the evaluation order of the receiver should be 0, the evaluation of the first argument should be 1, and so on.

[[[
Object subclass: #CHInterpretable
	instanceVariableNames: 'x collaborator evaluationOrder'
	classVariableNames: ''
	package: 'Champollion-Core'

CHInterpretable >> evaluationOrder [

  ^ evaluationOrder
]

CHInterpretable >> returnEvaluationOrder [

  ^ self evaluateReceiver
      messageArg1: self next
      arg2: self next
      arg3: self next
]

CHInterpretable >> evaluateReceiver [

  evaluationOrder := self next.
  ^ self
]

CHInterpretable >> messageArg1: arg1 arg2: arg2 arg3: arg3 [

  ^ {arg1. arg2. arg3}
]

CHInterpreterTests >> testEvaluationOrder [
  | argumentEvaluationOrder |
  argumentEvaluationOrder := self executeSelector: #returnEvaluationOrder.

  self assert: (self peanoToInt: receiver evaluationOrder) equals: 0.
  self
    assert: (argumentEvaluationOrder collect: [ :peano | self peanoToInt: peano])
    equals: #(1 2 3)
]
]]]

To make this test green we need to implement previously some new support in our interpreter: writing to temporary variables and dynamic literal arrays.

@@note OK, writing to temporaries is broken in P9. We should do it with an extension method? This is the same problem as before with name resolution...

[[[
CHInterpreter >> visitArrayNode: aRBArrayNode [
	
	^ aRBArrayNode statements collect: [ :e | self visitNode: e ] as: Array
]
]]]

At this point our test will fail because the evaluation order is wrong! The receiver was evaluated 4th, after all arguments. This is solved by changing the order of evaluation in ==visitMessageNode:==.

[[[
CHInterpreter >> visitMessageNode: aMessageNode [
	| newReceiver method args |
  "Evaluation Order:
    The receiver is evaluated before the arguments.
    Arguments are evaluated in left-to-right order."
	newReceiver := self visitNode: aMessageNode receiver.
	args := aMessageNode arguments collect: [ :each | self visitNode: each ].
	method := (newReceiver class compiledMethodAt: aMessageNode selector) ast.
	^ self executeMethod: method withReceiver: newReceiver andArguments: args
]
]]]

!!! Verifying Argument Access

We take some time to verify that the interpreter handles correctly argument. 

We define the method ==collaboratorXIgnoringArgumentWithSameName:== that does not use its parameter.

[[[
CHinterpretable >> collaboratorXIgnoringArgumentWithSameName: anInteger [
	collaborator x: 100 
]
]]]

We define the method ==changeCollaboratorXWithConflictingArgumentNames==.

[[[
CHinterpretable >> changeCollaboratorXWithConflictingArgumentNames
	collaborator collaboratorXIgnoringArgumentWithSameName: 1987
]]]

In the following test method, we set some state, then send a message to the method ==changeCollaboratorXWithConflictingArgumentNames==
that invokes the method ==collaboratorXIgnoringArgumentWithSameName:== whose argument has the same name that the method ==x:==
and it verifies that argument values did not interacted.
[[[
testArgumentAccessDoesNotEscapeItsDefinition [
	" changeCollaboratorXWithConflictingArgumentNames
		collaborator collaboratorXIgnoringArgumentWithSameName: 1987
	"
	receiver x: 200.
	collaborator x: 300.
	"Test precondition. Both methods have arguments with the same name.
	Otherwise this test could be green but false."
	self
		assert: (CHInterpretable >> #collaboratorXIgnoringArgumentWithSameName:) argumentNames
		equals: (CHInterpretable >> #x:) argumentNames.

	self executeSelector: #changeCollaboratorXWithConflictingArgumentNames.
	self assert: receiver x equals: 200.
	self assert: collaborator x equals: 100
]
]]]


!!! New Setup for Method Lookup

So far we have put aside the method lookup.
We looked directly in the class and this is clearly not good.

To test method lookup we introduce two superclasses as superclass of ==CHInterpretable==: 
The class ==CHInterpretableSecondSuperclass== and its subclass ==CHInterpretableSuperclass==.
With this setup we will be able to test all situations, even the ones which leads to infinite loops
when following the definition of some books.


[[[
Object subclass: #CHInterpretableSecondSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	package: 'Champollion-Core'
]]]

[[[
CHInterpretableSecondSuperclass subclass: #CHInterpretableSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	package: 'Champollion-Core'
]]]

[[[
CHInterpretableSuperclass subclass: #CHInterpretable
	instanceVariableNames: 'x collaborator'
	classVariableNames: ''
	package: 'Champollion-Core'
]]]

Since we may want to invoke method that are not directly defined in the class ==CHInterpretable==
but its superclasses, we adapt the helper method ==executeSelector:== to perform a lookup instead of accessible
only  ==CHInterpretable==.

[[[
CHInterpreterTest >> executeSelector: aSymbol [
	| ast |
	ast := (CHInterpretable lookupSelector: aSymbol) ast.
	^ self interpreter executeMethod: ast withReceiver: receiver
]
]]]

In addition we define the method ==methodNotInSubclass== only the superclass of ==CHInterpretable==.

[[[
CHInterpretableSuperclass >> methodNotInSubclass [
	^ 5
]
]]]

Now we are ready to define a test to verify that the method lookup is climbing up the inheritance tree when a 
method is not found.

[[[
CHInterpreterTest >> testLookupMessageInSuperclass [
	"CHInterpretable >> sendMessageInSuperclass
		^ self methodNotInSubclass
	CHInterpretableSuperclass >> methodNotInSubclass
		^ 5
	"
	self assert: (self executeSelector: #sendMessageInSuperclass) equals: 5
]
]]]


The test should not work so we are ready to work. 
We define the method ==lookup:fromClass:==. 
- It checks that the current class passed as argument defines the method. In such case it returns the corresponding method AST.
- If the method is not defined in the current class and we are not on the top of the hierarchy we recursively lookup from the superclass.
- Else when we are on top of the hierarchy the  ==lookup:fromClass:== returns nil. This indicates that no method were found. 

The method ==lookup:fromClass:== does not raise an error because this way the visitMessageNode: method will be able to send the ==doesNotUnderstand:== message to the receiver.

[[[
CHInterpreter >> lookup: aSymbol fromClass: aClass [
	"Return the AST of a method or nil if none is found"

	"If the class defines a method for the selector, return the AST corresponding to the method"
	(aClass includesSelector: aSymbol)
		ifTrue: [ ^ (aClass compiledMethodAt: aSymbol) ast ].

	"Otherwise lookup recursively in the superclass.
	If we reach the end of the hierarchy return nil"
	^ aClass = ProtoObject
		ifTrue: [ nil ]
		ifFalse: [ self lookup: aSymbol fromClass: aClass superclass ]
]
]]]

We should call the method ==lookup:fromClass:== from the ==visitMessageNode:==

[[[
CHInterpreter >> visitMessageNode: aMessageNode [
	| newReceiver method args | 
	newReceiver := self visitNode: aMessageNode receiver.
	args := aMessageNode arguments collect: [ :each | self visitNode: each ].
	method := self lookup: aMessageNode selector fromClass: newReceiver class.
	^ self executeMethod: method withReceiver: newReceiver andArguments: args
]
]]]

Now we are ready to work on the case of ==super==. 


!!! The Case of Super

Many people gets confused by super semantics even book authors. 
 ==super== is the receiver of the message as we saw it in the first chapter.
 It means that since ==self== and ==super== are pointing to the same object that 
 the difference should be elsewhere and it is in the lookup.

 We define a method ==superMessageSend==. 
 It is not really good since it uses ==super== while it is not needed. 
 We will see with the handling of overridden messages better 
 tests. 
 
[[[
CHInterpretable >> superMessageSend [
	^ super methodNotInSubclass
]
]]]



Once these methods defined, the following test 

[[[
CHInterpreterTest >> testLookupSuperMessage [
	"CHInterpretable >> superMessageSend
		^ super methodNotInSubclass
	Superclass >> methodNotInSubclass
		^ 5
	"
	self assert: (self executeSelector: #superMessageSend) equals: 5
]
]]]

The lookup of the method that should be executed when the receiver is ==super== does not look in the
class of the receiver but in the superclass of the class of the method containing the use of ==super==. 
It implies that we need a way to identify the method currently executed (whose )


We can store this information in the current frame as we do it in the following method ==executeMethod:withReceiver:andArguments:==.
By prefixing with ==\_\_\_==, we make sure that the key for the current method binding is unique. 
[[[
CHInterpreter >> executeMethod: anAST withReceiver: anObject andArguments: aCollection [
	| result |
	self pushNewFrame.
	self tempAt: #___method put: anAST.
	self tempAt: #self put: anObject.
	anAST arguments with: aCollection do: [ :arg :value | self tempAt: arg name put: value ]. 
	result := self visitNode: anAST body.
	self popFrame.
	^ result
]
]]]

We define the method ==currentMethod== to access the current method stored in the current frame.
[[[
CHInterpretable >> currentMethod [
	^ self tempAt: #___method
]
]]]

Note that using the current to store the current method will work, even if we have several messages in sequence. 
It will work since the stack is balanced: a new frame is pushed before any message is executed and popped after each message is executed.
So the frame will be always about the message it executes.

We redefine the ==visitMessageNode:== method to change class where to start looking for the method. 

[[[
CHInterpreterTest >> visitMessageNode: aMessageNode [

	| newReceiver method args lookupClass pragma | 
	newReceiver := self visitNode: aMessageNode receiver.
	args := aMessageNode arguments collect: [ :each | self visitNode: each ].
	
	lookupClass := aMessageNode receiver isSuper 
		ifTrue: [ self currentMethod methodClass superclass ] 
		ifFalse: [ newReceiver class ].
	method :=  self lookup: aMessageNode selector fromClass: lookupClass.	
	^ self executeMethod: method withReceiver: newReceiver andArguments: args
]
]]]	



!!! Overridden Messsages
So far we made sure that sending a message using ==super== starts in the superclass of the class using the expression. 
Now we would like to make sure that the lookup works even in presence of overridden methods. 

Let us define some method for our future tests. 
We define the method ==redefineMethod== in the subclass and the superclass.

[[[
CHInterpretable >> redefinedMethod [
	^ super redefinedMethod
]
]]]

[[[
CHInterpretableSuperClass >> redefinedMethod [
		^ 5
]
]]]

We defined a test which sends a message to the subclass instance and verifies that the 
method defined in the superclass is effectively executed. 

[[[
CHInterpreterTest >> testLookupRedefinedMethod [
	"CHInterpretable >> redefinedMethod
		^ super redefinedMethod
	CHInterpretableSuperClass >> redefinedMethod
		^ 5
	"
	self assert: (self executeSelector: #redefinedMethod) equals: 5
]
]]]

This test should run. 


!!! Checking Correct Semantics

Some books define wrongly that ==super== looks up method starting from the superclass of the class of the receiver. 
This is plain wrong and only works when the inheritance depth is limited to two: a class and its superclass.

The setup to define a sitation showing that with the previous wrong semantics the system loops is rather simple. 
We create an instance of the deepest subclass and define the method in its superclass to do a super call as shown by Figure *@fighierarchyFull*.

We define the method ==redefinedMethodAtThreeLevels== in the middle class. 
[[[
CHInterpretableSuperClass >> redefinedMethodAtThreeLevels [
	^ super redefinedMethodAtThreeLevels
	]
]]]

and redefine it in its superclass. 

[[[
CHInterpretableSecondSuperClass >> redefinedMethodAtThreeLevels [
	^ 5
]
]]]

+The full hierarchy of setup tests.>file://figures/hierarchy.pdf|width=80|label=fighierarchyFull+

The following test should pass. 

[[[
CHInterpreterTest >> testLookupSuperMessageNotInReceiverSuperclass [
	"
	This test tests that it does not loop!

	MiddleSuperclass>>redefinedMethodAtThreeLevels
		^ super redefinedMethodAtThreeLevels
	Superclass>>redefinedMethodAtThreeLevels
		^ 5
	"
	self assert: (self executeSelector: #redefinedMethodAtThreeLevels) equals: 5
	]
]]]


The following method reproduces the wrong semantics. Just watch out that the previous test will loop forever.

[[[
CHInterpreter >> visitMessageNode: aMessageNode [

	| newReceiver method args lookupClass | 
	newReceiver := self visitNode: aMessageNode receiver.
	args := aMessageNode arguments collect: [ :each | self visitNode: each ].
	lookupClass := aMessageNode receiver isSuper ifTrue: [ newReceiver class superclass ] ifFalse: [ newReceiver class ].
	method :=  self lookup: aMessageNode selector fromClass: lookupClass.
	^ self executeMethod: method withReceiver: newReceiver andArguments: args
]
]]]

We are ready to introduce temporaries.

!!! Intermezzo -- About Temporaries

Before implementing the interpretation of temporaries we want to show some particularities of Pharo semantics.
Temporaries cannot shadow other temporaries.

The following expression is rejected by the compiler because the second ==tmp== definition is illegal. 
[[[language=pharo
[ 
	| tmp |
	tmp := 2. 
	[
		| tmp |
		tmp := 3 ]]
]]]

Similarly a temporary cannot shadow a block or a method parameter.
Therefore the following expression is not allowed.

[[[language=pharo
	[ :tmp |
		| tmp |
		tmp := 2 ]
]]]

The following method is not valid either.
[[[language=pharo
with: arg

	| arg |
	^ arg
]]]	

!!!! Parameters are Read Only
Finally parameters are read only. 
Therefore the following method is not valid.
[[[language=pharo
with: arg
	arg := 42
]]]

As well as the following expression

[[[language=pharo
	[ :tmp |
		tmp := 2 ]
]]]



!!! Handling Temporaries

Inside a method, the names of parameters, temporaries and instance variables are flattened and use a single namespace.
We will manage temporaries the same way as parameters.

We start by defining a method just defining and not assigning any value to a temporary variable.

[[[
CHInterpretable >> returnUnassignedTemp [
	| temp |
	^ temp
]
]]]

The companion test verifies that the value of a uninitialized temporary is ==nil==.
[[[
CHInterpreterTest >> testUnassignedTempHasNilValue [
	self assert: (self executeSelector: #returnUnassignedTemp) equals: nil
]
]]]

The current subset of Pharo that we interpret does not contain blocks and their local/temporary variables.
Therefore the temporary variable management is rather simple.
We modify the == executeMethod:withReceiver:andArguments:== to define the temporaries needed.

[[[
CHInterpreter >> executeMethod: anAST withReceiver: anObject andArguments: aCollection [
	| result |
	self pushNewFrame.
	self tempAt: #___method put: anAST.
	self tempAt: #self put: anObject.
	anAST arguments with: aCollection do: [ :arg :value | self tempAt: arg name put: value ].
	anAST temporaryNames do: [ :tempName | self tempAt: tempName name put: nil ].
	result := self visitNode: anAST body.
	self popFrame.
	^ result
]
]]]

The value of a temporary variable is simply to return the value associated to the variable name in the current frame.
[[[
CHInterpreter >> visitTemporaryNode: aRBTemporaryNode [
	^ self tempAt: aRBTemporaryNode name
]
]]]

The test should be pass.

!!! Checking Temporary Writing
We test also that writing to a temporary variable is working.
We define the simple method ==writeTemporaryVariable==.

[[[
CHInterpretable >> writeTemporaryVariable [
	| temp |
	temp := 100.
	^ temp
]
]]]

Its companion test should pass.

[[[
CHInterpreterTest >> testWriteTemporaryVariable [
	"writeTemporaryVariable
		| temp |
		temp := 100.
		^ temp
	"
	self assert: (self executeSelector: #writeTemporaryVariable) equals: 100
]
]]]	

!!! Extended Read Temp Tests

We take the time to make sure that our implementation is correct. For example, temporaries should correctly
work when sending another message. 
The method ==readCollaboratorTemporaryVariable== defines locally a variable with the same name than ==returnUnassignedTemp==.
Within ==readCollaboratorTemporaryVariable== we assign the temp.
[[[
CHInterpretable >> readCollaboratorTemporaryVariable [
	| temp |
	temp := 17.
	^ collaborator returnUnassignedTemp
]
]]]

The companion test verifies that the assignment in one method does not affect the other.
[[[
CHInterpreterTest >> testReadTemporaryVariableDoesNotEscapeItsDefinition [
	"readCollaboratorTemporaryVariable
		| temp |
		temp := 17.
		^ collaborator returnUnassignedTemp
	
	returnUnassignedTemp
		| temp |
		^ temp
	"
	self assert: (self executeSelector: #readCollaboratorTemporaryVariable) equals: nil
]
]]]

We verifies the same situation after a message send by define the method ==readTemporaryVariableAfterMessageSend==
and a companion test.

[[[
CHInterpreterTest >> readTemporaryVariableAfterMessageSend [
	| temp |
	temp := 17.
	collaborator returnUnassignedTemp.
	^ temp
]
]]]

The test ==testReadTemporaryVariableAfterMessageSend== verifies that the vale of the variable ==temp==
is not changed by the message ==returnUnassignedTemp== that creates a new variable with the same name.

[[[
CHInterpreterTest >> testReadTemporaryVariableAfterMessageSend [
	"readTemporaryVariableAfterMessageSend
		| temp |
		temp := 17.
		collaborator returnUnassignedTemp.
		^ temp
	
	returnUnassignedTemp
		| temp |
		^ temp
	"
	self assert: (self executeSelector: #readTemporaryVariableAfterMessageSend) equals: 17
]
]]]


!!! Extended Write Temp Tests
We write some extra tests to verify that values get assigned to the correct temporaries. 
We define a new simple method ==writeCollaboratorTemporaryVariable== that sets a value to a temporary
with the same name as the ones defined in method ==writeTemporaryVariable==.
[[[
CHInterpretable >> writeCollaboratorTemporaryVariable [
	| temp |
	temp := 17.
	collaborator writeTemporaryVariable.
	^ temp
]
]]]

The test verifies that the semantics is correctly handled: a temporary access or store is only working on the associate
frame -- frame that is correctly push and pop on the stack. 
[[[
CHInterpreterTest >> testWriteTemporaryVariableDoesNotEscapeItsDefinition [
	"writeCollaboratorTemporaryVariable

		| temp |
		temp := 17.
		collaborator writeTemporaryVariable.
		^ temp
	
	writeTemporaryVariable

		| temp |
		temp := 100.
		^ temp
	"
	self assert: (self executeSelector: #writeCollaboratorTemporaryVariable) equals: 17
]
]]]

!!! Conclusion

In this chapter we extended the interpreter to handle message arguments, method temporaries and method lookup.
We revisited the semantics of ==self== and ==super==.


