!! Evaluating Message-sends

In the previous chapter we focused on structural evaluation: reading literal objects and reading and writing values from objects and globals. However, the key abstraction in object-oriented programming and in Pharo in particular is message-sending. 
The work we did in the previous chapter is nevertheless important to set up the stage: we have a better taste of the visitor pattern, we started a first testing infrastructure, and eventually message-sends need to carry out some work by using literal objects or reading and writing variables.

In this chapter we introduce message-sends. 
Message-sends deserve a chapter on their own because they introduce many different concerns. 
On the one hand, each message-send is resolved in two steps: first the method-lookup searches in the receiver's hierarchy the method to be executed, and second that method is applied on the receiver (i.e., it is evaluated with self bound to the receiver). The method-lookup algorithm needs to support normal message-sends as well as 'super' message-sends.  On the other hand, each method application needs to set up an execution context to store the receiver, arguments and temporary variables for that specific method execution. These execution contexts form the execution stack or call-stack. Sending a message pushes a new context in the call-stack, returning from a method pops a context from the call-stack.


!!! Introduction to Stack Management

The way we managed the receiver so far is overly simplistic.
Indeed, each time a program will send a message to another object, we should change the receiver and when the computation ends, the previous receiver should be put back. Moreover, the same happens with method arguments and temporaries. Therefore to introduce the notion of message-send we need a stack. And each element in the stack needs to capture all the execution state require to come back to it later on when a message-send will return. Each element in the call-stack is usually named a stack frame, an activation record, or in Pharo's terminology a context. For the rest of this book we will refer to them as frames, for shortness, and to distinguish them from the reified contexts from Pharo.

A first step to introduce stack management without breaking all our previous tests is to replace the single ==receiver== instance variable with a stack that will be initialized when the evaluator is created. The top of the stack will represent the current execution, and thus we will take the current receiver at each moment from the stack top. Moreover, each time we tell our interpreter to execute something we need to initialize our stack with a single frame.

@@todo add a diagram here with the stack

[[[caption=Replace the receiver instance variable by a stack
Object subclass: #CHInterpreter
	instanceVariableNames: 'stack'
	classVariableNames: ''
	package: 'Champollion-Core'

CHInterpreter >> initialize [
	super initialize. 
	stack := CTStack new.
]
]]]

With this new schema, we can now rewrite the access to the receiver to just access the value of ==#self== of the top frame. 

[[[language=pharo
CHInterpreter >> receiver [
	^ self topFrame at: #self
]

CHInterpreter >> topFrame [
	^ stack top
]
]]]

The final step is to set up a frame when the execution starts, which happened so far in our method ==execute:withReceiver:==. We extend the ==execute:withReceiver:== to create a new frame and define the receiver as ==#self== in the top frames before start the evaluation.

[[[language=pharo
CHInterpreter >> execute: anAST withReceiver: anObject [
	self pushNewFrame.
	self topFrame at: #self  put: anObject.
	^ self visitNode: anAST
]
]]]

The last piece in the puzzle is the method ==pushNewFrame==, which creates a new frame and pushes it on the top of the stack. 
For now, let's represent a frame as a dictionary that will store key-value pairs representing the variables defined in the current method execution: ==self==, and later the arguments and temporaries.

[[[
CHInterpreter >> pushNewFrame [
	| newTop |
	newTop := Dictionary new.
	stack push: newTop.
	^ newTop
]
]]]

This refactor kept all the test green, and opened the path to introduce message-sends.
As the reader may have observed, this stack can only grow.
We will take care of popping frames from the stack later when we revisit method returns.

!!! Evaluating a First Message Send

Let's start as usual by defining a new method exhibiting the scenario we want to work on.
In this case, we want to start by extending our evaluator to correctly evaluate return values of message sends.

Our scenario method ==sendMessageReturnX== does a self message-send and returns the value returned by this message send. On the one hand, we want that in our scenario the receiver of both messages is the same. On the other hand, we want that the message send is correctly evaluated to the return value of the activated method.

[[[language=pharo
CHInterpretable >> sendMessageReturnX [
	^ self returnX
]
]]]

Notice that our method ==sendMessageReturnX== and the implementation of the message it sends ==returnX== live in the same class. 
This means that in this first scenario we can concentrate on the stack management and return value of the message sends, without caring too much about the details of the method lookup algorithm. 
For this first version we will define a simple and incomplete yet useful method lookup algorithm.


@@todo SD-Guille I do not get the following paragraph - I could not really understand and I could not fix it. 

In our test we want to ensure that in a ==self== message-send, the receiver of both called and callee methods is the same. 
One way to do that is to mutate the receiver of the first message-send, and access one of its instance variables in the method that is activated by the second message-send.

[[[language=pharo
CHInterpreterTest >> testSelfSend [
	receiver x: 100.
	self 
		assert: (self executeSelector: #sendMessageReturnX) 
		equals: 100
]
]]]

To make this test green, we need to implement the method ==visitMessageNode:==.
Evaluation a message node requires that we recursively evaluate the receiver node, which may be a literal node or a complex expression such as another message-send.
From such an evaluation we obtain the actual receiver object. 
Starting from the receiver, we will lookup the method with the same selector as the message-send. 
In our first implementation we will just fetch the desired method's AST from the receiver's class. 
Finally, we can activate this method with the receiver using ==execute:withReceiver:== the activation will push a new frame to the call-stack with the given receiver, evaluate the method, and eventually return with a value.

[[[
CHInterpreter >> visitMessageNode: aMessageNode [
	| newReceiver method | 
	newReceiver := self visitNode: aMessageNode receiver.
	method := (newReceiver class compiledMethodAt: aMessageNode selector) ast.
	^ self execute: method withReceiver: newReceiver
]
]]]


!!! Balancing the Stack

We mentioned earlier that when the execution of a method is finished and the execution returns to its caller method, its frame should be also discarded from the stack. The current implementation clearly does not do it.
Indeed, we also said that our initial implementation of the stack only grows: as shown by the method ==executeMethod:withReceiver:==, our code never pops frames from the stack.

[[[language=pharo
CHInterpreter >> executeMethod: anAST withReceiver: anObject [
	self pushNewFrame.
	self topFrame at: #self  put: anObject.
	^ self visitNode: anAST
]
]]]

To solve this issue, let us write a test showing the problem first.
The idea of this test is that upon return, the frame of the caller method should be restored and with it its receiver. 
If we make that the caller and callee methods have different receiver instances, then this test can be expressed as some expression executed after a message-send returns. SD- I did not get the last part of the sentence.

The following code snippet shows an scenario that fulfills these requirements: it sets an instance variable with some value, sends a message to an object other than ==self== and upon its return it accesses its instance variable again before returning it. Assuming the collaborator object does not modify ==self==, then the result of evaluating this message should be that 1000 is returned.

[[[
CHInterpretable >> setXAndMessage [
		x := 1000.
		collaborator returnX.
		^ x
]
]]]

Our test ==testBalancingStack== executes the message ==setXAndMessage== that should return 1000.

[[[
CHInterpreterTest >> testBalancingStack [
	self
		assert: (self executeSelector: #setXAndMessage)
		equals: 1000
]
]]]

We then finish our setup by extending ==CHInterpretable== to support delegating to a collaborator object.
We add a ==collaborator== instance variable to the class ==CHInterpretable== with its companion accessors. 
This way we will be able to test that the correct object is set and passed around in the example.

[[[
Object subclass: #CHInterpretable
	instanceVariableNames: 'x collaborator'
	classVariableNames: ''
	package: 'Champollion-Core'

CHInterpretable >> collaborator [
	^ collaborator
]

CHInterpretable >> collaborator: anObject [
	collaborator := anObject
]
]]]

And in the ==setUp== method we pass a collaborator to our initial receiver.

[[[
CHInterpreterTest >> setUp [
	super setUp.
	receiver := CHInterpretable new.
	receiver collaborator: CHInterpretable new
]
]]]

!!!! Making the test pass

Executing this test breaks because the access to the instance variable ==x== returns nil, showing the limits of our current implementation.  This is due to the fact that evaluating message send ==returnX== creates a new frame with the collaborator as receiver, and since that frame is not popped from of the stack, when the method returns, the access to the ==x== instance variable accesses the one of the uninitialized collaborator instead of our receiver object.

To solve this problem, we should pop the frame when a method activation finishes. 
This way the stack is balanced. 
This is what the new implementation of ==executeMethod:withReceiver:==is doing.

[[[language=pharo
CHInterpreter >> executeMethod: anAST withReceiver: anObject [
	self pushNewFrame.
	self topFrame at: #self  put: anObject.
	result := self visitNode: anAST.
	self popFrame.
	^ result
]

CHInterpreter >> popFrame [
	stack pop
]
]]]


!!! Ensuring the receiver is correctly set: an Extra Test

Our previous tests did ensure that messages return the correct value, activate the correct methods, and that the stack grows and shrinks. However, we did not ensure yet that the receiver changes correctly on a message send, and since we do not lose any opportunity to strenghten our trust in our implementation with a new test, let's write a test for it.

The scenario, illustrated in ==changeCollaboratorX== will ask the collaborator to ==store100IntoX==, implemented previosly. In this scenario, we must ensure that the state of the receiver and the collaborator  are indeed separate and that changing the collaborator will not affect the initial receiver's state.

[[[
CHInterpretable >> changeCollaboratorX [
	collaborator store100IntoX
]
]]]

Our test for this scenario is as follows. 
If we give some value to the receiver and collaborator, executing our method should change the collaborator but not the initial receiver.

[[[
CHInterpreterTest >> testInstanceVariableStoreInMethodActivationDoesNotChangeSender [
	receiver x: 200.
	collaborator x: 300.

	"changeCollaboratorX will replace collaborator's x but not the receiver's"
	self executeSelector: #changeCollaboratorX.

	self assert: receiver x equals: 200.
	self assert: collaborator x equals: 100
]
]]]

To make our test run, we will store as a convenience the collaborator object in an instance variable of the test too.

[[[
TestCase subclass: #CHInterpreterTest
	instanceVariableNames: 'receiver collaborator'
	classVariableNames: ''
	package: 'Champollion-Tests'

CHInterpreterTest >> setUp [
	super setUp.
	receiver := CHInterpretable new.
	collaborator := CHInterpretable new.
	receiver collaborator: collaborator
]
]]]

This test passes, meaning that our implementation already covered correctly this case.
We are ready to continue our journey in message-sends.

!!! Supporting Message Arguments

So far we have worked only with unary messages. Unary messages have no arguments, so the number of programs we can express with them only is rather limited. The next step towards having a full-blown interpreter is to support message arguments, which will open us the door to support binary and keyword messages. From the evaluator point of view, as well as from the AST point of view, we will not distinguish between unary, binary and keyword messages. The parser already takes care about distinguishing them and handling their precedence. Indeed, message nodes in the AST are the same for all kind of messages, they have a selector and a collection of argument nodes. Precedence is then modelled as relationships between the AST nodes.


In addition of simply passing the arguments, from an evaluator point of view, we need to care about evaluation order too. This is particularly important because Pharo is an imperative language where messages can trigger side effects. Evaluating two messages in one order may not have the same result as evaluating them in a different order. Arguments in Pharo are evaluated eagerly after evaluating the receiver expression, but before evaluating the message, from left to right. Once all expressions are evaluated, the resulting objects are send as part of the message-send.

!!!! Initial Argument Support

To implement some initial support for arguments, our first scenario is to simply send a message with an argument. For our scenario we already count with one message with an argument: the ==x:== setter. We can then define a method ==changeCollaboratorWithArgument== which uses a it.

[[[language=smalltalk
CHInterpretable >> changeCollaboratorWithArgument [
	collaborator x: 500
]
]]]

In our test, we verify that the method evaluation effectively modifies the collaborator object 
as written in ==changeCollaboratorWithArgument==, and not the initial receiver object.

[[[language=smalltalk
CHInterpreterTest >> testArgumentAccess [

	receiver x: 200.
	collaborator x: 300.

	self executeSelector: #changeCollaboratorWithArgument.

	self assert: receiver x equals: 200.
	self assert: collaborator x equals: 500
]
]]]

Since we have not implemented any support for arguments yet, this test should fail.

Implementing argument support requires two main changes. On the caller side, we need to evaluate the arguments in the context of the caller method and then store those values in the new frame. On the callee side, when an argument access is evaluated, those accesses will not re-evaluate the expressions in the caller. Instead, argument access will just read the variables pre-stored in the current frame.

Let's start by defining the method ==visitArgumentNode:== to implement how a method accesses an argument. We implement this as a look-up in the current frame using the name of the argument.

[[[
CHInterpreter >> visitTemporaryNode: aRBArgumentNode [
	^ self topFrame at: aRBArgumentNode name
]
]]]

Then we need to update ==visitMessageNode:== to compute the arguments by doing a recursive evaluation, and then use those values during the new method activation.

[[[
CHInterpreter >> visitMessageNode: aMessageNode [
	| newReceiver method args |
	args := aMessageNode arguments collect: [ :each | self visitNode: each ].
	newReceiver := self visitNode: aMessageNode receiver.
	method := (newReceiver class compiledMethodAt: aMessageNode selector) ast.
	^ self executeMethod: method withReceiver: newReceiver andArguments: args
]
]]]

To include arguments in the method activation, let's add a new ==arguments== parameter to our method ==execute:withReceiver:== to get ==execute:withReceiver:withArguments:==. 
In addition to add the receiver to the new frame representing the execution, we add a binding for each parameter (called unfornately arguments in Pharo AST) with their corresponding value in the argument collection. We use the message ==with:do:== to iterate both the parameter list and actual arguments as pairs.

[[[
CHInterpreter >> execute: anAST withReceiver: anObject andArguments: aCollection [
	| result |
	self pushNewFrame.
	self tempAt: #self put: anObject.
	anAST arguments with: aCollection
    do: [ :arg :value | self topFrame at: arg name put: value ]. 
	result := self visitNode: anAST.
	self popFrame.
	^ result
]
]]]

Instead of just removing the old ==executeMethod:withReceiver:== method, we redefine it calling the new one with a default empty collection of arguments. This method was used as part of our public API so keeping it will avoid migrating extra code and an empty collection of arguments seems like a sensible and practical default.
 
[[[
CHInterpreter >> executeMethod: anAST withReceiver: anObject [
	 ^ self executeMethod: anAST withReceiver: anObject andArguments: #()
]
]]]

Our tests should all pass now.

!!!! Refactoring the Terrain

Let's now refactor a bit the existing code to clean it up and expose some existing but hidden functionality. Let us extract the code that accesses ==self== and the frame parameters into two other methods that make more intention revealing that we are accessing values in the current frame.

[[[
CHInterpreter >> tempAt: aSymbol [
	^ self topFrame at: aSymbol
]

CHInterpreter >> tempAt: aSymbol put: anInteger [
	self topFrame at: aSymbol put: anInteger
]

CHInterpreter >> execute: anAST withReceiver: anObject andArguments: aCollection [
	| result |
	self pushNewFrame.
	self tempAt: #self put: anObject.
	anAST arguments with: aCollection
    do: [ :arg :value | self tempAt: arg name put: value ]. 
	result := self visitNode: anAST.
	self popFrame.
	^ result
]

CHInterpreter >> receiver [

	^ self tempAt: #self
]

CHInterpreter >> visitTemporaryNode: aRBTemporaryNode [

	^ self tempAt: aRBTemporaryNode name
]
]]]

!!!! Evaluation Order

The last thing we need to make sure is that arguments are evaluated in the correct order.
The evaluation order in Pharo goes as follows: before evaluating a message, the receiver and all arguments are evaluated. The receiver is evaluated before the arguments. Arguments are evaluated in left-to-right order.

Testing the evaluation order in a black-box fashion as we were doing so far is rather challenging with our current evaluator. Indeed, our evaluator does not yet handle arithmetics, allocations nor other kind of primitive. A simple approach to test is to make a counter out of *Peano Axioms>https://en.wikipedia.org/wiki/Peano_axioms*. The main idea is to implement numbers as sets, where the empty set is the zero, the set that contains the zero is one, the set that contains a one is a two, and so on. The only support we need for this is to extend our literal support for dynamic array literals. The code illustrating the idea follows.

[[[
CHInterpretable >> initialize [
  super initialize.
  current := { "empty" }.
]

CHInterpretable >> next [
  | next |
  "Implement a stream as an increment in terms of Peano axioms.
  See https://en.wikipedia.org/wiki/Peano_axioms"
  next := current.
  current := { current }.
  ^ next
]

CHInterpreterTests >> peanoToInt: aPeanoNumber [
  "Helper method to transform a peano number to a normal Pharo integer"
  ^ aPeanoNumber
    ifEmpty: [ 0 ]
    ifNonEmpty: [ 1 + (self peanoToInt: aPeanoNumber first) ]
]
]]]

Using this support, we can express our evaluation order scenario and test as follows.
We will add a new instance variable to ==CHInterpretable== to store its evaluation order.
Then, we are going to send a message with many arguments, evaluating for each argument ==self next==.
The message receiving the many arguments will then receive as argument the three generated peano values, that we will return as dynamic literal array. If evaluation order is right, the evaluation order of the receiver should be 0, the evaluation of the first argument should be 1, and so on.

[[[
Object subclass: #CHInterpretable
	instanceVariableNames: 'x collaborator evaluationOrder'
	classVariableNames: ''
	package: 'Champollion-Core'

CHInterpretable >> evaluationOrder [

  ^ evaluationOrder
]

CHInterpretable >> returnEvaluationOrder [

  ^ self evaluateReceiver
      messageArg1: self next
      arg2: self next
      arg3: self next
]

CHInterpretable >> evaluateReceiver [

  evaluationOrder := self next.
  ^ self
]

CHInterpretable >> messageArg1: arg1 arg2: arg2 arg3: arg3 [

  ^ {arg1. arg2. arg3}
]

CHInterpreterTests >> testEvaluationOrder [
  | argumentEvaluationOrder |
  argumentEvaluationOrder := self executeSelector: #returnEvaluationOrder.

  self assert: (self peanoToInt: receiver evaluationOrder) equals: 0.
  self
    assert: (argumentEvaluationOrder collect: [ :peano | self peanoToInt: peano])
    equals: #(1 2 3)
]
]]]

To make this test green we need to implement previously some new support in our interpreter: writing to temporary variables and dynamic literal arrays.

@@note OK, writing to temporaries is broken in P9. We should do it with an extension method? This is the same problem as before with name resolution...

[[[
CHInterpreter >> visitArrayNode: aRBArrayNode [
	
	^ aRBArrayNode statements collect: [ :e | self visitNode: e ] as: Array
]
]]]

At this point our test will fail because the evaluation order is wrong! The receiver was evaluated 4th, after all arguments. This is solved by changing the order of evaluation in ==visitMessageNode:==.

[[[
CHInterpreter >> visitMessageNode: aMessageNode [
	| newReceiver method args |
  "Evaluation Order:
    The receiver is evaluated before the arguments.
    Arguments are evaluated in left-to-right order."
	newReceiver := self visitNode: aMessageNode receiver.
	args := aMessageNode arguments collect: [ :each | self visitNode: each ].
	method := (newReceiver class compiledMethodAt: aMessageNode selector) ast.
	^ self executeMethod: method withReceiver: newReceiver andArguments: args
]
]]]

!!! Handling Temporaries

Temporary variables, or local variables, are variables that live within the scope of a method's execution.
Memory for such variables is allocated when a method is activated, and released when the method returns.
Because of this property, temporary variables are also called automatic variables in languages like C.

The usual way to implement such temporary variables is to allocate them in the method execution's frame.
In that way, when the method returns, the frame is popped and all the values allocated in temporaries are discarded and can be reclaimed. In other words, we will manage temporaries the same way as we manage parameters.

Our first scenario introducing temporaries will verify the default value of temporaries.
Indeed when temporaries are allocated in Pharo, the execution engine (in this case our evaluator) should make sure these variables are correctly initialized to a default value, in this case ==nil==.

Notice that temporaries cannot be observed from outside the execution of a method unless we halt the evaluation of a method in the middle of the evaluation. Since our testing approach is more like a black-box approach, we need to make our scenarios visible from the outside somehow. Because of these reasons, our tests will rely on returns again, as we did before with literal objects.

[[[
CHInterpretable >> returnUnassignedTemp [
	| temp |
	^ temp
]
]]]

The companion test verifies that the value of a uninitialized temporary is ==nil==.

[[[
CHInterpreterTest >> testUnassignedTempHasNilValue [
	self
    assert: (self executeSelector: #returnUnassignedTemp)
    equals: nil
]
]]]

The current subset of Pharo that we interpret does not contain blocks and their local/temporary variables.
Therefore the temporary variable management we need to implement so far is rather simple.
We will implement blocks and more complex lexical scopes in a later chapter.
To make our test green, we modify our == execute:withReceiver:andArguments:== method to define the temporaries needed with ==nil== as value.

[[[
CHInterpreter >> executeMethod: anAST withReceiver: anObject andArguments: aCollection [
	| result |
	self pushNewFrame.
	self tempAt: #self put: anObject.
	anAST arguments with: aCollection do: [ :arg :value | self tempAt: arg name put: value ].
	anAST temporaryNames do: [ :tempName | self tempAt: tempName name put: nil ].
	result := self visitNode: anAST body.
	self popFrame.
	^ result
]
]]]

@@note Guille: this we already implemented it above because arguments are temps...!!!!
And the value of a temporary variable is simply to return the value associated to the variable name in the current frame.
[[[
CHInterpreter >> visitTemporaryNode: aRBTemporaryNode [
	^ self tempAt: aRBTemporaryNode name
]
]]]

The test should be pass.

!!!! Implementing Temporary Variable Writes

Finally we test that writes to temporary variables are working too.
We define our scenario method ==writeTemporaryVariable==, which defines a temporary variable, assigns to it and returns it. An optimizing compiler for this code would be smart enough to do constant propagation of the literal integer and then realize that the temporary is dead code and remove it, leaving us with a method body looking like == ^ 100 ==. However, since the parser does not do such optimizations by itself, we are sure that the AST we are going to receive contains both the temporary definition, the assignment, and the temporary return.

[[[
CHInterpretable >> writeTemporaryVariable [
	| temp |
	temp := 100.
	^ temp
]
]]]

Its companion test checks that evaluating this method does effectively return 100, meaning that the temporary variable write succeeded, and that `temp` means the same variable in the assignment and in the access.

[[[
CHInterpreterTest >> testWriteTemporaryVariable [

	self
    assert: (self executeSelector: #writeTemporaryVariable)
    equals: 100
]
]]]

@@note Guille: again this is weird from a reader point of view, we did not implement anything for it. The store:... is hiding so much stuff, and we did not even really talk about it...

!!!! A Paragraph on Name Conflict Resolution

Inside the scope of a method, statements have access to parameters, temporaries, instance and global variables. A name conflict appears when two variables that should be visible in a method share the same name. In a conflict scenario the language developer needs to device a resolution strategy for these problems, to avoid ambiguities.

For example, consider a method ==m:== that has an argument named ==integer== and defines a temporary variable also named ==integer==. How should values of that name be resolved? How are assignments resolved? A conflict resolution strategy provides a set of deterministic rules to answer these questions and let developers understand what their program do in a non-ambiguous way.

A first simple strategy to avoid conflicts is preventing them at construction time. That is, the language should not allow developers to define variables if they generate a name conflict. For example, a method should not be able to define a temporary variable with the same name as an instance variable of its class. Usually these validations are done once at compile time, and programs that do not follow this rules are rejected.

Another strategy to solve this problem is to allow shadowing. That is, we give each variable in our program a priority, and then the actual variable to read or write is looked-up using this priority system.
Typically priorities in these schemas are modelled as lexical scopes. Lexical scoping divides a program in a hierarchy of scopes. Each scope defines variables and all but the top level scope have a parent scope. For example, the top level scope defines global variables, the class scope defines the instance variables, the method scope defines the parameters and temporaries. In this way, variable visibility can be defined in terms of a scope: the variables visible in a scope are those defined in the scope or in the parents of the scope. Moreover, scoping also gives a conflict resolution strategy: variables defined closer to the current scope in the scope hierarchy have more priority than those defined higher in the scope hierarchy.

@@note should we or not?
In the scope of these first chapters we will not manage conflict resolution explicitly. Name resolution is previously done in the AST semantic analysis upon which we are building our evaluator. This means name resolution is already resolved for us following the Opal compiler semantics: shadowing is forbidden.

!!! Introducing the Method Lookup

So far we have concentrated on method evaluation and put aside the method lookup.
Our current solution fetches methods from the class of the receiver, without respecting inheritance.
In this section we will remedy this problem in our evaluator and implement a proper method lookup algorithm.

To implement and test the method lookup, we will extend our scenario classes with a class hierarchy.
We introduce two superclasses above ==CHInterpretable==: ==CHInterpretableSecondSuperclass== and its subclass ==CHInterpretableSuperclass==.
With this setup we will be able to test all interesting situations, even the ones leading to infinite loops
if our method lookup is wrongly implemented.

[[[
Object subclass: #CHInterpretableSecondSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	package: 'Champollion-Core'
]]]

[[[
CHInterpretableSecondSuperclass subclass: #CHInterpretableSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	package: 'Champollion-Core'
]]]

[[[
CHInterpretableSuperclass subclass: #CHInterpretable
	instanceVariableNames: 'x collaborator evaluationOrder current'
	classVariableNames: ''
	package: 'Champollion-Core'
]]]


Our first scenario for method lookup will check that sending a message climbs up the inheritance tree when a method is not found in the receiver's class class. In the code below, we define a method in ==CHInterpretable== that does a ==self== message whose method is implemented in its ==CHInterpretableSuperclass== superclass. Executing the first method should send the message, find the superclass method, and evaluate it.

[[[
CHInterpretableSuperclass >> methodInSuperclass [
	^ 5
]

CHInterpretable >> sendMessageInSuperclass [
	^ self methodInSuperclass
]

CHInterpreterTest >> testLookupMessageInSuperclass [
	self assert: (self executeSelector: #sendMessageInSuperclass) equals: 5
]
]]]

The test should fail with our evaluator as is, because the evaluation of the message send will not find the method in the receiver's class. A first step towards implementing the lookup is to refactor the method ==visitMessageNode:== and extract the wrong code into a ==lookup:fromClass:== method.

[[[
CHInterpreter >> visitMessageNode: aMessageNode [
	| newReceiver method args |
	newReceiver := self visitNode: aMessageNode receiver.
	args := aMessageNode arguments collect: [ :each | self visitNode: each ].
	method := self lookup: aMessageNode selector fromClass: newReceiver class.
	^ self execute: method withReceiver: newReceiver andArguments: args
]

CHInterpreter >> lookup: aSelector fromClass: aClass [
  ^ (aClass compiledMethodAt: aMessageNode selector) ast.
]
]]]

The method ==lookup:fromClass:== is now the place to implement the method lookup algorithm:
- if the current class defines the method returns the corresponding AST;
- if the current class does not define the method and we are not on the top of the hierarchy we recursively lookup in the class' superclass;
- else when we are on top of the hierarchy the  ==lookup:fromClass:== returns nil to indicate that no method was found.

The method ==lookup:fromClass:== does not raise an error because this way the ==visitMessageNode:== method will be able to send the ==doesNotUnderstand:== message to the receiver, as we will see later in this chapter.

[[[
CHInterpreter >> lookup: aSymbol fromClass: aClass [
	"Return the AST of a method or nil if none is found"

	"If the class defines a method for the selector, return the AST corresponding to the method"
	(aClass includesSelector: aSymbol)
		ifTrue: [ ^ (aClass compiledMethodAt: aSymbol) ast ].

	"Otherwise lookup recursively in the superclass.
	If we reach the end of the hierarchy return nil"
	^ aClass superclass
		ifNil: [ nil ]
		ifNotNil: [ self lookup: aSymbol fromClass: aClass superclass ]
]
]]]

We should call the method ==lookup:fromClass:== from the ==visitMessageNode:==

!!!! The Case of Super

Many people gets confused by the semantics of ==super==. The ==super== variable has two different roles in the execution of an object oriented language. When the ==super== variable is read, its value is the receiver of the message as we saw it in the first chapter, it has the same value as ==self==.

The second role of the ==super== variable is to alter the method lookup when ==super== is used as the receiver of the message send. Whe ==super== is used as the receiver of a message send, the method lookup does not start at the class of the receiver, but at the class where the method is installed instead, allowing it to go up higher and higher in the hierarchy.

We define a method ==superMessageSend==. 
 It is not really good since it uses ==super== while it is not needed. 
 We will see with the handling of overridden messages better 
 tests. 
 
[[[
CHInterpretableSuperclass >> isInSuperclass [
	^ true
]

CHInterpretable >> isInSuperclass [
	^ false
]

CHInterpretable >> doesSuperLookupFromSuperclass [
	^ super isInSuperclass
]
]]]

Once these methods defined, we can now test that the ==isInSuperclass== message activates the method in the superclass, returning ==true==.

[[[
CHInterpreterTest >> testLookupSuperMessage [
	self assert: (self executeSelector: #doesSuperLookupFromSuperclass)
]
]]]

The ==super== variable changes the method lookup described above.
When the receiver is ==super==, the lookup does not start from the class of the receiver, but from the superclass of the class defining the method of the current frame. 
This implies that we need a way to access the method that is being current executed, and the class where it is defined.

We can again store this information in the current frame during the method's activation.
We will add it for now as a fake temporary variable in the frame, with the name ==\_\_\_method==.
By prefixing the variable's name with ==\_\_\_== we make it less probable this fake variable creates a conflict with a real variable. If we would have just named it e.g., ==method==, any method with a normal normal temporary called ==method== would be broken.

[[[
CHInterpreter >> executeMethod: anAST withReceiver: anObject andArguments: aCollection [
	| result |
	self pushNewFrame.
	self tempAt: #___method put: anAST.
	self tempAt: #self put: anObject.
	anAST arguments with: aCollection do: [ :arg :value | self tempAt: arg name put: value ]. 
	result := self visitNode: anAST body.
	self popFrame.
	^ result
]
]]]

We also define a convenience accessor method ==currentMethod==, to get the current method stored in the current frame. In the future, if we want to change this implementation, we will have less places to change if we hide the access to the method behind an accessor.

[[[
CHInterpretable >> currentMethod [
	^ self tempAt: #___method
]
]]]

Note that using the current frame to store the current method will work, even if we have several messages in sequence. When a message is sent a new frame is pushed with a new method, and upon return the frame is popped along with its method. So the top frame in the stack will be always contain the method it executes.
Finally, we redefine the ==visitMessageNode:== method to change class where to start looking for the method. 

[[[
CHInterpreterTest >> visitMessageNode: aMessageNode [

	| newReceiver method args lookupClass pragma | 
	newReceiver := self visitNode: aMessageNode receiver.
	args := aMessageNode arguments collect: [ :each | self visitNode: each ].
	
	lookupClass := aMessageNode receiver isSuper 
		ifTrue: [ self currentMethod methodClass superclass ] 
		ifFalse: [ newReceiver class ].
	method := self lookup: aMessageNode selector fromClass: lookupClass.	
	^ self executeMethod: method withReceiver: newReceiver andArguments: args
]
]]]

!!!! Overridden Messsages

We have made sure that sending a message to ==super== starts looking methods in the superclass of the class defining the method. Now we would like to make sure that the lookup works even in presence of overridden methods. 

Let's define the method ==overriddenMethod== in a superclass returning a value, and in a subclass just doing a super send with the same selector. If our implementation is correct, sending the ==overriddenMethod== message to our test receiver should return ==5==. If it is not, the test should fail, or worse, loop infinitely.

[[[
CHInterpretableSuperClass >> overriddenMethod [
	^ 5
]

CHInterpretable >> overriddenMethod [
	^ super overriddenMethod
]
]]]

Then we check that our test returns the correct value. If the test loops infinitely the test will timeout.

[[[
CHInterpreterTest >> testLookupRedefinedMethod [
	self assert: (self executeSelector: #overriddenMethod) equals: 5
]
]]]

If our previous implementation was correct, this test should run green.


!!!! Checking Correct Semantics

To ensure that the method lookup is correctly implemented, especially in the presence of ==super== messages, we need to verify an extra condition. Lot of material wrongly defines that ==super== messages look up methods starting from the superclass of the class of the receiver. This definition, illustrated in the code snippet below, is incorrect: it only works when the inheritance depth is limited to two classes, a class and its superclass. In other cases, this definition will create an infinite loop.

[[[
CHInterpreter >> visitMessageNode: aMessageNode [
	| newReceiver method args lookupClass | 
	newReceiver := self visitNode: aMessageNode receiver.
	args := aMessageNode arguments collect: [ :each | self visitNode: each ].

	lookupClass := aMessageNode receiver isSuper
    ifTrue: [ newReceiver class superclass ]
    ifFalse: [ newReceiver class ].
	method :=  self lookup: aMessageNode selector fromClass: lookupClass.

	^ self executeMethod: method withReceiver: newReceiver andArguments: args
]
]]]

A scenario showing such problem is shown in Figure *@fighierarchyFull*.
In this scenario, our inheritance depth is of three classes and we will create two methods with the same selector.
In the higher class in the hierarchy the method returns a value.
In the middle class, the first method is overridden doing a super send.

+The full hierarchy of setup tests.>file://figures/hierarchy.pdf|width=80|label=fighierarchyFull+

[[[
CHInterpretableSecondSuperClass >> redefinedMethodAtThreeLevels [
	^ 5
]
  
CHInterpretableSuperClass >> redefinedMethodAtThreeLevels [
	^ super redefinedMethodAtThreeLevels
]
]]]

To finish our scenario, we create an instance of the lower subclass in the hierarchy, and we send it a message with the offending selector.

[[[
CHInterpreterTest >> testLookupSuperMessageNotInReceiverSuperclass [
	self assert: (self executeSelector: #redefinedMethodAtThreeLevels) equals: 5
]
]]]

With the incorrect semantics, our test will start by activating ==CHInterpretableSuperclass>>#redefinedMethodAtThreeLevels==.
When our evaluator finds the super send, it will start the lookup from the superclass of the receiver's class: ==CHInterpretableSuperclass==. Starting the lookup from this class will again find and activate ==CHInterpretableSuperclass>>#redefinedMethodAtThreeLevels==, which will lead to activating the same method over and over again...

Coming back to our previous, correct, definition works properly, and makes our test green:

[[[
CHInterpreterTest >> visitMessageNode: aMessageNode [

	| newReceiver method args lookupClass pragma | 
	newReceiver := self visitNode: aMessageNode receiver.
	args := aMessageNode arguments collect: [ :each | self visitNode: each ].
	
	lookupClass := aMessageNode receiver isSuper 
		ifTrue: [ self currentMethod methodClass superclass ] 
		ifFalse: [ newReceiver class ].
	method := self lookup: aMessageNode selector fromClass: lookupClass.	
	^ self executeMethod: method withReceiver: newReceiver andArguments: args
]
]]]

!!! Does not understand and Reifications

To finish this chapter we will implement in our interpreter support for the ==doesNotUnderstand:== feature.
In Pharo, when an object receives a message for which the lookup does not find a corresponding method, it will send instead the ==doesNotUnderstand:== message to that object, with the "original message" as argument. This original message is not only the selector but it comprises the arguments too. The interpreter should take selector and arguments to create an object representation of the message. We say the interpreter reifies the message.

!!!! About Reifications

Reification is the process of making concrete something that was not. In the case of the interpreter of a programming language, many of the operations of the language are implicit and hidden in the interpreter execution. For example, the implementation of message-sends and assignments are hidden to the developer. While information hiding in interpreters is important to make languages safe and sound, the language has no way to manipulate those abstractions. Reifications enter in the game to enable those manipulations: interpreter concepts are concretized as objects in the interpreted language, they are "lifted-up" from the interpreter level to the application.

Reifications are a powerful concept that allow us to manipulate implementation concerns from the language itself. In this case, the does not understand mechanism allows us to intercept the failing message-lookup algorithm and to implement in our program a strategy to handle the error. There exist in Pharo many different reifications such as classes and methods. In the scope of interpreters, we will see in the chapters that follow other kind of reification: context objects representing execution frames.

A word is to be said about the performance implications of reifications. Reifications add levels of indirection in the execution, and allocate objects adding a significant overhead in the interpretation, and increasing the pressure in the garbage collector. Production interpreters try to minimize this cost to delay reifications as much as possible, and avoid them when they are not necessary. This is what we will do with message reifications: we will create them when a method-lookup effectively fails and not before, penalizing only the execution of does not understand messages.

!!!! Implementing ==doesNotUnderstand:==

To implement the does not understand feature, let's start by setting up our testing scenario: a method sending a not understood ==messageIDoNotUnderstandWithArg1:withArg:2== message. This message should be looked-up and not found, so our interpreter should send a ==doesNotUnderstand:== message to the same receiver with the message reification. For the message reification, we are going to follow Pharo's behaviour and expect an instance of ==Message== that should have the selector and an array with all the arguments.

[[[
CHInterpretable >> doesNotUnderstand: aMessage [
	^ aMessage
]
  
CHInterpretable >> sendMessageNotUnderstood [
	^ self messageIDoNotUnderstandWithArg1: 17 withArg2: 27
]

CHInterpreterTest >> testDoesNotUnderstandReifiesMessageWithSelector [
	self
    assert: (self executeSelector: #sendMessageNotUnderstood) selector
    equals: #messageIDoNotUnderstandWithArg1:withArg2:
]

CHInterpreterTest >> testDoesNotUnderstandReifiesMessageWithArguments [
	self
    assert: (self executeSelector: #sendMessageNotUnderstood) arguments
    equals: #( 17 27 )
]
]]]

These two tests will fail in the interpreter, because the method lookup will return ==nil==, which will fail during method activation. To fix it, we need to handle this problem and send the ==doesNotUnderstand:== message, as we said before.

[[[
CHInterpreter >> visitMessageNode: aMessageNode [

  	| newReceiver method args lookupClass |
  	newReceiver := self visitNode: aMessageNode receiver.
  	args := aMessageNode arguments collect: [ :each | 
  		        self visitNode: each ].

  	lookupClass := aMessageNode receiver isSuperVariable
  		               ifTrue: [ self currentMethod methodClass superclass ]
  		               ifFalse: [ newReceiver class ].
  	method := self lookup: aMessageNode selector fromClass: lookupClass.
  	method ifNil: [ | doesNotUnderstandMethod messageReification |
  		"Handle does not understand:
  		 - lookup the #doesNotUnderstand: selector
  		 - reify the message
  		 - activate"
  		doesNotUnderstandMethod := self lookup: #doesNotUnderstand: fromClass: lookupClass.
  		messageReification := Message
  			selector: aMessageNode selector
  			arguments: args asArray.
  		^ self execute: doesNotUnderstandMethod withReceiver: newReceiver andArguments: { messageReification } ].

  	^ self execute: method withReceiver: newReceiver andArguments: args
]
]]]

Note that reifying does not understand requires that our interpreter knows two new things about our language: what selector is used for ==#doesNotUnderstand:==, and what class is used to reify ==Message==. In this case we are implementing a Pharo evaluator that runs in the same environment as the evaluated program: they share the same memory, classes, global variables. Because of this we make use of the existing selector and classes in Pharo. In contrast, implementing an evaluator that runs on a different environment than the evaluated program (e.g., a Pharo evaluator implemented in C), such dependencies need to be made explicit through a clear language-interpreter interface.

!!!! Refactoring

As a final step, we can proceed to refactor our ==visitMessageNode:== to avoid repeating some code.
We can proceed to extract the method activation and send, separating it from the decision of the class to start the lookup.

[[[
CHInterpreter >> send: aSelector receiver: newReceiver lookupFromClass: lookupClass arguments: arguments [
  	"Lookup a selector from a class, and activate the method.
  	Handle does not undertand case and message reification on demand if lookup fails."

  	| method |
  	method := self lookup: aSelector fromClass: lookupClass.
  	method ifNil: [ | messageReification |
  		"Handle does not understand:
  		 - lookup the #doesNotUnderstand: selector
  		 - reify the message
  		 - activate"
  		messageReification := Message
  			selector: aSelector
  			arguments: arguments.
  		^ self
          send: #doesNotUnderstand:
          newReceiver: receiver
          lookupFromClass: lookupClass
          arguments: { messageReification } ].

  	^ self execute: method withReceiver: newReceiver andArguments: arguments
]
]]]

And then make use of it in ==visitMessageNode:==.

[[[
CHInterpreter >> visitMessageNode: aMessageNode [

	| newReceiver args lookupClass |
	newReceiver := self visitNode: aMessageNode receiver.
	args := aMessageNode arguments collect: [ :each | 
		        self visitNode: each ].

	lookupClass := aMessageNode receiver isSuperVariable
		               ifTrue: [ self currentMethod methodClass superclass ]
		               ifFalse: [ newReceiver class ].
	^ self
		send: aMessageNode selector
		receiver: newReceiver
		lookupFromClass: lookupClass
		arguments: args asArray
]
]]]

!!! Conclusion

In this chapter we extended our interpreter to evaluate messages.
Messages are the arguably the most important part of our interpreter, as operations in object-oriented languages are expressed in terms of them. It is also the most complex part that we have implemented so far.

Implementing messages implied modelling the call-stack and keeping it balanced on method returns.
We have seen that a call-stack is made up of frames, each frame representing the activation of a method: it stores the method, receiver, arguments, and temporaries of the method that is executing. When a message takes place, receiver and arguments are evluated in order from left to right, a new frame is created and all values are stored in the frame.

At the end of this chapter we have seen the method lookup algorithm to resolve what method to execute given a receiver and a selector. We have also seen the particularities of ==self== and ==super== sends. Finally we have shown how the ==doesNotUnderstand:== feature is implemented, by handling the lookup error, and we introduced the concept of reification to concretize and lift-up the failing message from our evaluator to the language.
