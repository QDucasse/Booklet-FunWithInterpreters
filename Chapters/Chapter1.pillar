!! A First Interpreter: A Simple Evaluator

In this chapter we will develop step by step a Pharo program interprerter.
We will incrementally add support for language characteristics.
Here is the progression: returning constants, accessing receiver state, instance variable assignment, simple temporaries, self messages, ....



For each of the steps we will start by defining a method illustrating the situation, then we define a test and 
we implement the features. 

Doing so we will define and refine a visitor. 
Note that we will write the visitor from scratch but we will reuse the node of the Pharo AST and their functionalities.

!!! Setting the stage

The tests that we will define are hosted in the class ==CHInterpreterTest==.

[[[
TestCase subclass: #CHInterpreterTest
	instanceVariableNames: 'interpreter'
	classVariableNames: ''
	package: 'Champollion-Core'
]]]

We define two helper methods: ==interpreter== and ==interpreterClass== as follows: 

[[[
CHInterpreterTest >> interpreter
	^ interpreter
]]]


[[[
CHInterpreterTest >> interpreterClass 
	^ CHInterpreter
]]]


[[[
CHInterpreterTest >> setUp
	super setUp.
	interpreter := self interpreterClass new
]]]

!!! Hosting Code of be Tested
We prefer to separate the code that we will use to test the behavior of our interpreter from the test class itself. It will give us more possibility to describe different situations in the future.

The class ==Interpretable== is a class hosting the sample methods that we will execute. 


[[[
Object subclass: #CInterpretable
	instanceVariableNames: ''
	classVariableNames: ''
	package: 'Champollion'
]]]

Here we define some simple methods that we would like to execute.
For now we focus on returning simple literal objects such as booleans, float and integer. 

[[[
CInterpretable >> returnInteger
	^ 5
]]]

[[[
CInterpretable >> returnFloat
	^ 3.14
]]]

[[[
CInterpretable >> returnBoolean
	^ false
]]]


!!! A First Test

The method ==testReturnInteger== is the first test for specifying the behavior of simple interpreter. 

[[[
CHInterpreterTest >> testReturnInteger

	| ast result |
	ast := (Interpretable >> #returnInteger) ast.
	result := self interpreter execute: ast. 
	self assert: result equals: 5
]]]

Our first test is worth one comment: 
- we access the AST of the method that we want to execute
- then we instantiate our interpreter and 
- ask it to execute the ast.
And we check that we get the expected result. 

!!! Building a minimal constant evaluator

We are ready to define our interpreter. 
We define the class ==CHInterpreter==. 
We will implement it as a Visitor over the Pharo method AST. 

[[[
Object subclass: #CHInterpreter
	instanceVariableNames: ''
	classVariableNames: ''
	package: 'Champollion'
]]]

Note that we do not inherit from the default Pharo AST Visitor so that we build it step by step. 
Nevertheless we follow the same API and use the node ==accept:== visit methods.
The method ==execute:== simply calls the visitor main entry point (method ==visitNode:==).

[[[
CHInterpreter >> execute: anAST
	^ self visitNode: anAST
]]]

[[[
CHInterpreter >> visitNode: aNode
	^ aNode acceptVisitor: self
]]]

Since the AST we will interpret is an AST of method, 
The first visitor method of interest is the method ==visitMethodNode:==.
It just dispatches on ==visitMethodBodyNode:==.

[[[
CHInterpreter >> visitMethodNode: aMethodNode

	^ self visitMethodBodyNode: aMethodNode body
]]]

For now ==visitMethodBodyNode:== just visits the method body (an ==RBSequenceNode==).
[[[
CHInterpreter >> visitMethodBodyNode: aMethodBodyNode
	^ self visitNode: aMethodBodyNode 
]]]

The first version of ==visitSequenceNode:== ignores possible temporary declarations and handles all the statements paying attention that the last statement value should be returned.
So we visit all the statements except the last one, and we return the value of the last statement. 

[[[
CHInterpreter >> visitSequenceNode: aSequenceNode
	
	aSequenceNode statements allButLast 
		do: [ :each | self visitNode: each ].
	^ self visitNode: aSequenceNode statements last
]]]

Since we want to be able to access a return value, we define the ==visitReturnNode:== to handle. This method simply returns the value (invoking recursively the visitor) of the expression that is returned.

[[[
CHInterpreter >> visitReturnNode: aReturnNode

	^ self visitNode: aReturnNode value
]]]

For now we only manage literal object such as number, booleans, ...
So we redefine the method ==visitLiteralValueNode:== which is invoked on literal values. 

[[[
CHInterpreter >> visitLiteralValueNode: aRBLiteralValueNode

	^ aRBLiteralValueNode value
]]]

Our first test passes. 
And we are ready to continue our journey.



!!! Improving the Test Infrastructure

Since we will write many tests during this book, we exact some logic from our test method, it will help future evolution. 

We define the method ==executeSelector:==, it accesses the method, gets its AST and returns the value of the  execution of the ast.
[[[
CHInterpreterTest >> executeSelector: aSymbol

	| ast |
	ast := (CInterpretable >> aSymbol) ast.
	^ self interpreter executeMethod: ast
	
]]]

Now we rewrite our first test as follows: 

[[[
CHInterpreterTest >> testReturnInteger

	self 
		assert: (self executeSelection: #returnInteger)
		equals: 5
]]]

We are ready to efficiently write tests for the other constants. 

!!! More Tests for Constant

It is straigth forward to write new tests. 
We define a test for booleans, here we do not use ==deny:== to make the result explicit.
Note that we include the method definition ofthe interpreted method to ease understanding. 

[[[
CHInterpreterTest >> testReturnBoolean
	"returnBoolean
		^ false"
		
	self assert: (self executeSelector: #returnBoolean) equals: false 
]]]

[[[
CHInterpreterTest >> testReturnFloat
	"returnFloat
		^ 3.14"
	self assert: (self executeSelector: #returnFloat) equals: 3.14 
]]]


!!! Literal Array

We add support for Array. 
First we define some method returning an empty array and a literal array. 

[[[
CInterpretable >> returnEmptyArray
	^ #()
]]]

[[[
CInterpretable >> returnLiteralArray
	^ #(true 1 'ahah')
]]]

We add a test to cover case.


[[[
CHInterpreterTest >> testReturnEmptyArray

	self 
		assert: (self executeSelector: #returnEmptyArray) 
		equals: #() 
]]]


[[[
CHInterpreterTest >> testReturnLiteralArray

	self 
		assert: (self executeSelector: #returnLiteralArray) 
		equals: #(true 1 'ahah')
]]]

We now have to implement the method ==visitLiteralArrayNode:== to handle arrays.
Here we return the values returned by the interpretation of the elements. 

[[[
CHInterpreter >> visitLiteralArrayNode: aRBLiteralArrayNode 
	
	^ aRBLiteralArrayNode contents 
			collect: [ :each | self visitNode: each ] 
]]]

The tests are green.
Up until now we did not consider that any form of variable and we should handle such case.

!!! Handling Self 
The first kind of variable that we handle is ==self== that represents the receiver of the message. 
THe first things we need to do is to make sure that we can specify the receiver of a message


Since we need to have access to the receiver for now we add an instance variable called ==receiver==.
This is a super naive way to handle it since we will need a way to automatically manage receiver and arguments.

[[[
Object subclass: #CHInterpreter
	instanceVariableNames: 'receiver'
	classVariableNames: ''
	package: 'Champollion'
]]]

We define an accessor so that we can easily adapt when we will introduce a better way representation later. 

[[[
CHInterpreter >> receiver
	^ receiver
]]]

We make sure that we can set the receiver when we launch the interpretation and we introduce a new method ==execute:with:== for this. 
We will remove 
[[[
CHInterpreter >> execute: anAST withReceiver: anObject

	receiver := anObject.
	^ self visitNode: anAST
]]]

We redefine the method ==executeSelector:== to use this new method.

[[[
CHInterpreterTest >> executeSelector: aSymbol

	| ast |
	ast := (CInterpretable >> aSymbol) ast.
	^ self interpreter executeMethod: ast withReceiver: nil.
]]]

This way all our tests are still passing and we will be ready to handle the case of ==self== and ==super==.


[[[
CInterpretable >> returnSelf
	^ self 
]]]

[[[
CHInterpreterTest >> testReturnSelf

	self 
		assert: (self executeSelector: #returnSelf) 
		equals: nil
]]]

The interpretation of ==self== is done in the method ==visitSelfNode:==.
It is simple, it just returns the value of the receiver stored in the interpreter.

[[[
CInterpretable >> visitSelfNode: aRBSelfNode 
	^ self receiver
]]]

!!! Handling Super
Following the same logic as for ==self==, we improve the interpreter to support ==super==.

We start by defining a method using ==super== and its companion test. 

[[[
CInterpretable >> returnSuper
	^ super
]]]

[[[
CHInterpreterTest >> testReturnSuper

	self 
		assert: (self executeSelector: #returnSuper) 
		equals: nil
]]]

What is interesting is that the interpretation of ==super== is that this variable is also the receiver of the message. 
So contrary to a common and wrong believe, ==super== is not the superclass or an instance of the superclass. It is just the receiver.

[[[
CHInterpreter >> visitSuperNode: aRBSelfNode 
	^ self receiver
]]]

The logic of the tests is not really satisfactory, so we improve it. 

!!! Improving the Logic of setUp

We want to have a better way to handle receiver in test.
We add an instance variable to the ==CHInterpreterTest== that will hold the receiver.

[[[
TestCase subclass: #CHInterpreterTest
	instanceVariableNames: 'interpreter receiver'
	classVariableNames: ''
	package: 'Champollion'
]]]

In the ==setUp== we assign a new instance to the new instance variable.
[[[
CHInterpreterTest >> setUp
	super setUp.
	interpreter := self interpreterClass new.
	receiver := CInterpretable new
]]]

We then use the new instance variable in ==executeSelector:==.

[[[
CHInterpreterTest >> executeSelector: aSymbol

	| ast |
	ast := (CInterpretable >> aSymbol) ast.
	^ self interpreter executeMethod: ast withReceiver: receiver
]]]

We rewrite the test methods ==testReturnSelf== and ==testReturnSuper==.
[[[
CHInterpreterTest >> testReturnSelf

	self 
		assert: (self executeSelector: #returnSelf) 
		equals: receiver
]]]

[[[
CHInterpreterTest >> testReturnSuper

	self 
		assert: (self executeSelector: #returnSuper) 
		equals: receiver
]]]


We are ready to work on more interesting points. 



!!! Receiver State Access

We can work on support instance variable access. 
Let us start with a test.

!!!!! Fixture and Test

We define a getter and setter to be able to control the value put in the instance variable of our instance.

[[[
CInterpretable >> returnX
	^ x 
]]]
 
[[[
CInterpretable >> x: anInteger
	x := anInteger
]]]

We modify the receiver and when we interpret the accessor we should get the correct value.

[[[
CHInterpreterTest >> testReturnAccessInstanceVariable

	receiver x: 100.
	self assert: (self executeSelector: #returnX) equals: 100
]]]


Our test is failing so we are ready to work.  And now we can define the method ==visitInstanceVariableNode:== to reflectivity access the state of receiver. Note that this implementation does not take into account the fact that an instance variable can be defined in a superclass and still be accessible in the subclass method. 

[[[
CHInterpreter >> visitInstanceVariableNode: aVariableNode
	^ receiver instVarNamed: aVariableNode name
]]]

Our test should pass!

!!! Receiver State Assignment
We will add support for assignment in receiver's instance variables.

!!!!! Fixture and Tests

We define a method doing an assignment into the instance variable ==x==.
[[[
CInterpretable >> store100IntoX
	x := 100.
]]]

[[[
Interpretable >> x
	^ x 
]]]

The test ==testStore100IntoX== launches the interpretation of method ==store100IntoX==.

[[[
CHInterpreterTest >> testStore100IntoX

	receiver x: 17.
	self executeSelector: #store100IntoX.
	self assert: receiver x equals: 100
]]]

!!!!! Implementation

The implementation is straighforward. We define the method ==visitAssignmentNode:==.
Here since we expect to have other variable types in the future we define the storing behavior  (method == store:with:==) of the assigned variable node itself. 

[[[
BasicInterpreter >> visitAssignmentNode: anAssignmentNode
	" x := 100"
	
	| value | 
	value := (self visitNode: anAssignmentNode value).
	anAssignmentNode variable store: value with: self.
	^ value
]]]


[[[
RBInstanceVariableNode >> store: anObject with: anInterpreter 
	
	anInterpreter receiver instVarNamed: name put: anObject
]]]

Now our tests should pass. 




!!! Introducing Stack Management

The way we managed the receiver is overly simplistic.
 Indeed, each time a program will send a message to another object,  we should change the receiver and when the computation ends, the previous receiver should be put back. Therefore we need a stack.
In addition the same happens for handling methods arguments and temporaries. 
We address this point now.

We add a stack instance and this stack will keep information about the current receiver, as well as temporaries and arguments as we will see later. 

[[[
Object subclass: #CHInterpreter
	instanceVariableNames: 'stack'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Champollion-Core'
]]]

The idea is that the stack will hold a ''frame''. A frame can be represented for now as a dictionary. 
We define the method ==pushNewFrame==. This means that we add on the top of the stack a new dictionary instance. 

[[[
CHInterpreter >> pushNewFrame
	"Pushing a new scope consists in creating a new dictionary whose parent is the top of the stack
	and pushing it as a new top. This way a variable not found in current scope will be looked up in previous scope."

	| newTop |
	newTop := Dictionary new.
	stack push: newTop.
	^ newTop
]]]

We initialize the interpreter state by creating a new stack. 

[[[
CHInterpreter >> initialize 
	super initialize. 
	stack := CTStack new.
]]]

Accessing the receiver is just accessing the value of the key ==#self== of the current frame. 

[[[
CHInterpreter >> receiver
	^ self topFrame at: #self
]]]

We expose also the top frame to ease manipulation. 
[[[
CHInterpreter >> topFrame
	^ stack top 
]]]

We extend the ==executeMethod:withReceiver:== to create a new frame and define the receiver as value of the ==#self== key.

[[[
CHInterpreter >> executeMethod: anAST withReceiver: anObject
	self pushNewFrame.
	self topFrame at: #self  put: anObject.
	^ self visitNode: anAST
]]]


!!! Intermezzo -- About temporaries

Before implementing the interpretation of temporaries we want to show some particularities of Pharo semantics.
Temporaries cannot shadow other temporaries.

The following expression is rejected by the compiler because the second ==tmp== definition is illegal. 
[[[
[ 
	| tmp |
	tmp := 2. 
	[
		| tmp |
		tmp := 3 ]]
]]]

Similarly a temporary cannot shadow a block or a method parameter.
Therefore the following expression is not allowed.
[[[
[ :tmp |
	| tmp |
	tmp := 2]
]]]

The following method is not valid either.
[[[
with: arg

	| arg |
	^ arg
]]]	

Finally parameters are read only. 
Therefore the following method is not valid. 
[[[
with: arg
	arg := 42	
]]]

As well as the following expression

[[[
[ :tmp |
	tmp := 2
	 ]
]]]

We can say that inside a method the names of parameters, temporaries and instance variables are flattened and use a single namespace.


!!! Temporaries

Here!


[[[
CHInterpreter >> visitAssignmentNode: anAssignmentNode
	"| x y |
	x := y := 10.
	x
	>>> 10"
	
	| value | 
	value := (self visitNode: anAssignmentNode value).
	anAssignmentNode variable store: value with: self.
	^ value
]]]


[[[
CBasicInterpreterTest >> testTempsAccessShouldNotEscapeMethods

	| ast result |
	ast := (CInterpretable >> #methodWithTemp) ast.
	result := self interpreter execute: ast withReceiver: CInterpretable new. 
	self assert: result equals: nil 
]]]


[[[
CBasicInterpreterTest >> testTempsShouldNotEscapeMethods

	| ast result |
	ast := (CInterpretable >> #methodWithTemp) ast.
	result := self interpreter execute: ast withReceiver: CInterpretable new. 
	self assert: result equals: nil 
]]]

[[[
CBasicInterpreterTest >> testTempsWritingShouldNotEscapeMethods

	| ast result |
	ast := (CInterpretable >> #methodCallingModifyingTemp) ast.
	result := self interpreter execute: ast withReceiver: CInterpretable new. 
	self assert: result equals: 7
]]]


[[[
BasicInterpreter1Test >> testAccessInstanceVariable

	| ast result |
	ast := (CInterpretable >> #returnX) ast.
	result := self interpreter execute: ast withReceiver: (CInterpretable new x: 100).
	self assert: result equals: 100. 
	
]]]



[[[
BasicInterpreter1Test >> testAccessXInInstance

	| ast result |
	ast := (CInterpretable >> #returnX) ast.
	result := self interpreter execute: ast withReceiver: (CInterpretable new x: 100).
	self assert: result equals: 100. 
	
]]]



!!! Handling Global Variables

[[[
CInterpretable >> returnGlobal

	^ Global
]]]

[[[
CHInterpreterTest >> testReturnGlobal

	| globalObject |
	globalObject := Object new.
	interpreter globalEnvironmentAt: #Global put: globalObject. 
	self assert: (self executeSelector: #returnGlobal) equals: globalObject  
]]]


[[[
Object subclass: #CHInterpreter
	instanceVariableNames: 'stack globalEnvironment'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Champollion-Core'
]]]

[[[
CHInterpreter >> globalEnvironmentAt: aSymbol put: anObject 
	globalEnvironment at: aSymbol put: anObject
]]]

[[[
CHInterpreter >> initialize 
	super initialize. 
	stack := CTStack new.
	globalEnvironment := Dictionary new.

]]]



[[[
CHInterpreter >> visitGlobalNode: aRBGlobalNode 

	^ self globalEnvironment at: aRBGlobalNode name 
		ifAbsent: [ self error: aRBGlobalNode name, ' not found' ]
]]]





!!! Conclusion
This interpreter is basic. It does not cover blocks and more dynamic features. 
We will cover more advanced topics in the following chapter.
