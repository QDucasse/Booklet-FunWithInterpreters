!! A First Interpreter: A Simple Evaluator

In this chapter we will develop step by step a Pharo program interprerter.
We will incrementally add support for language characteristics.
Here is the progression: returning constants, accessing receiver state, instance variable assignment, simple temporaries, self messages, ....



For each of the steps we will start by defining a method illustrating the situation, then we define a test and 
we implement the features. 

Doing so we will define and refine a visitor. 
Note that we will write the visitor from scratch but we will reuse the node of the Pharo AST and their functionalities.

!!! Setting the stage

The tests that we will define are hosted in the class ==CHInterpreterTest==.

[[[
TestCase subclass: #CHInterpreterTest
	instanceVariableNames: 'interpreter'
	classVariableNames: ''
	package: 'Champollion-Core'
]]]

We define two helper methods: ==interpreter== and ==interpreterClass== as follows: 

[[[
CHInterpreterTest >> interpreter
	^ interpreter
]]]


[[[
CHInterpreterTest >> interpreterClass 
	^ CHInterpreter
]]]


[[[
CHInterpreterTest >> setUp
	super setUp.
	interpreter := self interpreterClass new
]]]

!!! Hosting Code of be Tested
We prefer to separate the code that we will use to test the behavior of our interpreter from the test class itself. It will give us more possibility to describe different situations in the future.

The class ==Interpretable== is a class hosting the sample methods that we will execute. 


[[[
Object subclass: #CInterpretable
	instanceVariableNames: ''
	classVariableNames: ''
	package: 'Champollion'
]]]

Here we define some simple methods that we would like to execute.
For now we focus on returning simple literal objects such as booleans, float and integer. 

[[[
CInterpretable >> returnInteger
	^ 5
]]]

[[[
CInterpretable >> returnFloat
	^ 3.14
]]]

[[[
CInterpretable >> returnBoolean
	^ false
]]]


!!! A First Test

The method ==testReturnInteger== is the first test for specifying the behavior of simple interpreter. 

[[[
CHInterpreterTest >> testReturnInteger

	| ast result |
	ast := (Interpretable >> #returnInteger) ast.
	result := self interpreter execute: ast. 
	self assert: result equals: 5
]]]

Our first test is worth one comment: 
- we access the AST of the method that we want to execute
- then we instantiate our interpreter and 
- ask it to execute the ast.
And we check that we get the expected result. 

!!! Building a minimal constant evaluator

We are ready to define our interpreter. 
We define the class ==CHInterpreter==. 
We will implement it as a Visitor over the Pharo method AST. 

[[[
Object subclass: #CHInterpreter
	instanceVariableNames: ''
	classVariableNames: ''
	package: 'Champollion'
]]]

Note that we do not inherit from the default Pharo AST Visitor so that we build it step by step. 
Nevertheless we follow the same API and use the node ==accept:== visit methods.
The method ==execute:== simply calls the visitor main entry point (method ==visitNode:==).

[[[
CHInterpreter >> execute: anAST
	^ self visitNode: anAST
]]]

[[[
CHInterpreter >> visitNode: aNode
	^ aNode acceptVisitor: self
]]]

Since the AST we will interpret is an AST of method, 
The first visitor method of interest is the method ==visitMethodNode:==.
It just dispatches on ==visitMethodBodyNode:==.

[[[
CHInterpreter >> visitMethodNode: aMethodNode

	^ self visitMethodBodyNode: aMethodNode body
]]]

For now ==visitMethodBodyNode:== just visits the method body (an ==RBSequenceNode==).
[[[
CHInterpreter >> visitMethodBodyNode: aMethodBodyNode
	^ self visitNode: aMethodBodyNode 
]]]

The first version of ==visitSequenceNode:== ignores possible temporary declarations and handles all the statements paying attention that the last statement value should be returned.
So we visit all the statements except the last one, and we return the value of the last statement. 

[[[
CHInterpreter >> visitSequenceNode: aSequenceNode
	
	aSequenceNode statements allButLast 
		do: [ :each | self visitNode: each ].
	^ self visitNode: aSequenceNode statements last
]]]

Since we want to be able to access a return value, we define the ==visitReturnNode:== to handle. This method simply returns the value (invoking recursively the visitor) of the expression that is returned.

[[[
CHInterpreter >> visitReturnNode: aReturnNode

	^ self visitNode: aReturnNode value
]]]

For now we only manage literal object such as number, booleans, ...
So we redefine the method ==visitLiteralValueNode:== which is invoked on literal values. 

[[[
CHInterpreter >> visitLiteralValueNode: aRBLiteralValueNode

	^ aRBLiteralValueNode value
]]]

Our first test passes. 
And we are ready to continue our journey.



!!! Improving the Test Infrastructure

Since we will write many tests during this book, we exact some logic from our test method, it will help future evolution. 

We define the method ==executeSelector:==, it accesses the method, gets its AST and returns the value of the  execution of the ast.
[[[
CHInterpreterTest >> executeSelector: aSymbol

	| ast |
	ast := (CInterpretable >> aSymbol) ast.
	^ self interpreter executeMethod: ast
	
]]]

Now we rewrite our first test as follows: 

[[[
CHInterpreterTest >> testReturnInteger

	self 
		assert: (self executeSelection: #returnInteger)
		equals: 5
]]]

We are ready to efficiently write tests for the other constants. 

!!! More Tests for Constant

It is straigth forward to write new tests. 
We define a test for booleans, here we do not use ==deny:== to make the result explicit.
Note that we include the method definition ofthe interpreted method to ease understanding. 

[[[
CHInterpreterTest >> testReturnBoolean
	"returnBoolean
		^ false"
		
	self assert: (self executeSelector: #returnBoolean) equals: false 
]]]

[[[
CHInterpreterTest >> testReturnFloat
	"returnFloat
		^ 3.14"
	self assert: (self executeSelector: #returnFloat) equals: 3.14 
]]]


!!! Literal Array

We add support for Array. 
First we define some method returning an empty array and a literal array. 

[[[
CInterpretable >> returnEmptyArray
	^ #()
]]]

[[[
CInterpretable >> returnLiteralArray
	^ #(true 1 'ahah')
]]]

We add a test to cover case.


[[[
CHInterpreterTest >> testReturnEmptyArray

	self 
		assert: (self executeSelector: #returnEmptyArray) 
		equals: #() 
]]]


[[[
CHInterpreterTest >> testReturnLiteralArray

	self 
		assert: (self executeSelector: #returnLiteralArray) 
		equals: #(true 1 'ahah')
]]]

We now have to implement the method ==visitLiteralArrayNode:== to handle arrays.
Here we return the values returned by the interpretation of the elements. 

[[[
CHInterpreter >> visitLiteralArrayNode: aRBLiteralArrayNode 
	
	^ aRBLiteralArrayNode contents 
			collect: [ :each | self visitNode: each ] 
]]]

The tests are green.
Up until now we did not consider that any form of variable and we should handle such case.

!!! Handling Self 
The first kind of variable that we handle is ==self== that represents the receiver of the message. 
THe first things we need to do is to make sure that we can specify the receiver of a message


Since we need to have access to the receiver for now we add an instance variable called ==receiver==.
This is a super naive way to handle it since we will need a way to automatically manage receiver and arguments.

[[[
Object subclass: #CHInterpreter
	instanceVariableNames: 'receiver'
	classVariableNames: ''
	package: 'Champollion'
]]]

We define an accessor so that we can easily adapt when we will introduce a better way representation later. 

[[[
CHInterpreter >> receiver
	^ receiver
]]]

We make sure that we can set the receiver when we launch the interpretation and we introduce a new method ==execute:with:== for this. 
We will remove 
[[[
CHInterpreter >> execute: anAST withReceiver: anObject

	receiver := anObject.
	^ self visitNode: anAST
]]]

We redefine the method ==executeSelector:== to use this new method.

[[[
CHInterpreterTest >> executeSelector: aSymbol

	| ast |
	ast := (CInterpretable >> aSymbol) ast.
	^ self interpreter executeMethod: ast withReceiver: nil.
]]]

This way all our tests are still passing and we will be ready to handle the case of ==self== and ==super==.


[[[
CInterpretable >> returnSelf
	^ self 
]]]

[[[
CHInterpreterTest >> testReturnSelf

	self 
		assert: (self executeSelector: #returnSelf) 
		equals: nil
]]]

The interpretation of ==self== is done in the method ==visitSelfNode:==.
It is simple, it just returns the value of the receiver stored in the interpreter.

[[[
CInterpretable >> visitSelfNode: aRBSelfNode 
	^ self receiver
]]]

!!! Handling Super
Following the same logic as for ==self==, we improve the interpreter to support ==super==.

We start by defining a method using ==super== and its companion test. 

[[[
CInterpretable >> returnSuper
	^ super
]]]

[[[
CHInterpreterTest >> testReturnSuper

	self 
		assert: (self executeSelector: #returnSuper) 
		equals: nil
]]]

What is interesting is that the interpretation of ==super== is that this variable is also the receiver of the message. 
So contrary to a common and wrong believe, ==super== is not the superclass or an instance of the superclass. It is just the receiver.

[[[
CHInterpreter >> visitSuperNode: aRBSelfNode 
	^ self receiver
]]]

The logic of the tests is not really satisfactory, so we improve it. 

!!! Improving the Logic of setUp

We want to have a better way to handle receiver in test.
We add an instance variable to the ==CHInterpreterTest== that will hold the receiver.

[[[
TestCase subclass: #CHInterpreterTest
	instanceVariableNames: 'interpreter receiver'
	classVariableNames: ''
	package: 'Champollion'
]]]

In the ==setUp== we assign a new instance to the new instance variable.
[[[
CHInterpreterTest >> setUp
	super setUp.
	interpreter := self interpreterClass new.
	receiver := CInterpretable new
]]]

We then use the new instance variable in ==executeSelector:==.

[[[
CHInterpreterTest >> executeSelector: aSymbol

	| ast |
	ast := (CInterpretable >> aSymbol) ast.
	^ self interpreter executeMethod: ast withReceiver: receiver
]]]

We rewrite the test methods ==testReturnSelf== and ==testReturnSuper==.
[[[
CHInterpreterTest >> testReturnSelf

	self 
		assert: (self executeSelector: #returnSelf) 
		equals: receiver
]]]

[[[
CHInterpreterTest >> testReturnSuper

	self 
		assert: (self executeSelector: #returnSuper) 
		equals: receiver
]]]




































!!! Introducing Stack Management

[[[
Object subclass: #CHInterpreter
	instanceVariableNames: 'stack'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Champollion-Core'
]]]

[[[
CHInterpreter >> pushNewFrame
	"Pushing a new scope consists in creating a new dictionary whose parent is the top of the stack
	and pushing it as a new top. This way a variable not found in current scope will be looked up in previous scope."

	| newTop |
	newTop := Dictionary new.
	stack push: newTop.
	^ newTop
	
]]]

[[[
CHInterpreter >> initialize 
	super initialize. 
	stack := CTStack new.
	self pushNewFrame
]]]


[[[
CHInterpreter >> receiver

	^ self topFrame at: #self
]]]

[[[
CHInterpreter >> executeMethod: anAST withReceiver: anObject
	self pushNewFrame.
	^ self visitNode: anAST
]]]



[[[
CHInterpreter >> visitSelfNode: aRBSelfNode 
	^ self receiver
]]]

[[[
CBasicInterpreter >> visitReturnNode: aReturnNode

	| res |
	res := self visitNode: aReturnNode value.
	^ res
]]]




!!! Assignment Nodes


[[[
CHInterpreter >> visitAssignmentNode: anAssignmentNode
	"| x y |
	x := y := 10.
	x
	>>> 10"
	
	| value | 
	value := (self visitNode: anAssignmentNode value).
	anAssignmentNode variable store: value with: self.
	^ value
]]]










[[[
CHInterpreterTest >> testReturnBoolean

	| ast result |
	ast := (CInterpretable >> #returnBoolean) ast.
	result := self interpreter executeMethod: ast withReceiver: nil. 
	self deny: result 
]]]

[[[
CHInterpreterTest >> testReturnBoolean

	| ast result |
	ast := (CInterpretable >> #returnBoolean) ast.
	result := self interpreter executeMethod: ast withReceiver: nil. 
	self assert: result equals: false 
]]]














[[[
CHInterpreter >> executeMethod: anAST withReceiver: anObject
	self pushNewFrame.
	self currentFrame at: #self  put: anObject.
	^ self visitNode: anAST
]]]

[[[
CHInterpreter >> executeMethod: anAST withReceiver: anObject
	self pushNewFrame.
	self topFrame at: #self  put: anObject.
	^ self visitNode: anAST
]]]

[[[
CHInterpreter >> topFrame

	^ stack top 
]]]

[[[
CHInterpreter >> receiver

	^ self topFrame at: #self
]]]

[[[
CHInterpreterTest >> testReturnSuper

	self assert: (self executeSelector: #returnSuper) equals: receiver
]]]

[[[
CHInterpreterTest >> testReturnBoolean

	| globalObject |
	globalObject := Object new.
	interpreter globalEnvironmentAt: #Global put: globalObject. 
	self assert: (self executeSelector: #returnGlobal) equals: globalObject  
]]]

[[[
CHInterpreterTest >> testReturnGlobal

	| globalObject |
	globalObject := Object new.
	interpreter globalEnvironmentAt: #Global put: globalObject. 
	self assert: (self executeSelector: #returnGlobal) equals: globalObject  
]]]

[[[
CHInterpreterTest >> testReturnBoolean

	self assert: (self executeSelector: #returnBoolean) equals: false 
]]]


!!! Handling Global Variables

[[[
CInterpretable >> returnGlobal

	^ Global
]]]

[[[
CHInterpreterTest >> testReturnGlobal

	| globalObject |
	globalObject := Object new.
	interpreter globalEnvironmentAt: #Global put: globalObject. 
	self assert: (self executeSelector: #returnGlobal) equals: globalObject  
]]]


[[[
Object subclass: #CHInterpreter
	instanceVariableNames: 'stack globalEnvironment'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Champollion-Core'
]]]

[[[
CHInterpreter >> globalEnvironmentAt: aSymbol put: anObject 
	globalEnvironment at: aSymbol put: anObject
]]]

[[[
CHInterpreter >> initialize 
	super initialize. 
	stack := CTStack new.
	globalEnvironment := Dictionary new.

]]]



[[[
CHInterpreter >> visitGlobalNode: aRBGlobalNode 

	^ self globalEnvironment at: aRBGlobalNode name 
		ifAbsent: [ self error: aRBGlobalNode name, ' not found' ]
]]]

!!! Instance variable 

[[[
CHInterpreter >> visitInstanceVariableNode: aVariableNode

	^ self receiver instVarNamed: aVariableNode name
]]]

!!! Assignment 

[[[
CHInterpreter >> visitAssignmentNode: anAssignmentNode
	"| x y |
	x := y := 10.
	x
	>>> 10"
	
	| value | 
	value := (self visitNode: anAssignmentNode value).
	anAssignmentNode variable store: value with: self.
	^ value
]]]




[[[
CHInterpreter >> visitLiteralArrayNode: aRBLiteralArrayNode 
	
	^ aRBLiteralArrayNode contents collect: [ :each | self visitNode: each ] 
]]]



[[[
CHInterpreter >> visitGlobalNode: aRBGlobalNode 

	^ globalEnvironment at: aRBGlobalNode name ifAbsent: [ self error: aRBGlobalNode name, ' not found' ]
]]]


[[[
CHInterpreter >> visitSelfNode: aRBSelfNode 
	^ self receiver
]]]


[[[
CHInterpreter >> visitSuperNode: aRBSuperNode 
	^ self receiver
]]]

[[[
CHInterpreter >> topFrame

	^ stack top 
]]]

[[[
CHInterpreter >> pushNewFrame
	"Pushing a new scope consists in creating a new dictionary whose parent is the top of the stack
	and pushing it as a new top. This way a variable not found in current scope will be looked up in previous scope."

	| newTop |
	newTop := Dictionary new.
	stack push: newTop.
	^ newTop
	
]]]


[[[
CHInterpreter >> visitGlobalNode: aRBGlobalNode 

	^ globalEnvironment at: aRBGlobalNode name ifAbsent: [ self error: aRBGlobalNode name, ' not found' ]
]]]

[[[
CHInterpreter >> visitMethodNode: aMethodNode
	
	^ self visitMethodBodyNode: aMethodNode body
]]]

[[[
CHInterpreter >> visitMethodBodyNode: aMethodBodyNode
	^ self visitNode: aMethodBodyNode 
]]]

[[[
CHInterpreter >> visitSelfNode: aRBSelfNode 
	^ self receiver
]]]

[[[
CHInterpreter >> visitReturnNode: aReturnNode

	| res |
	res := self visitNode: aReturnNode value.
	^ res
]]]

[[[
CHInterpreter >> visitAssignmentNode: anAssignmentNode
	"| x y |
	x := y := 10.
	x
	>>> 10"
	
	| value | 
	value := (self visitNode: anAssignmentNode value).
	anAssignmentNode variable store: value with: self.
	^ value
]]]

[[[
CHInterpreter >> visitInstanceVariableNode: aVariableNode

	^ self receiver instVarNamed: aVariableNode name
]]]


[[[
CHInterpreter >> visitSuperNode: aRBSuperNode 
	^ self receiver
]]]

[[[
CHInterpreter >> executeMethod: anAST withReceiver: anObject
	self pushNewFrame.
	self topFrame at: #self  put: anObject.
	^ self visitNode: anAST
]]]


[[[
CHInterpreter >> execute: anAST withReceiver: anObject

	self newFrame.
	^ self visitNode: anAST
]]]

[[[
CHInterpreter >> pushNewFrame
	"Pushing a new scope consists in creating a new dictionary whose parent is the top of the stack
	and pushing it as a new top. This way a variable not found in current scope will be looked up in previous scope."

	| newTop |
	newTop := Dictionary new.
	stack push: newTop.
	^ newTop
	
]]]

[[[
CHInterpreter >> receiver

	^ self topFrame at: #self
]]]

[[[
CHInterpreter >> topFrame

	^ stack top 
]]]

[[[
CHInterpreter >> visitLiteralValueNode: aRBLiteralValueNode

	^ aRBLiteralValueNode value
]]]


[[[
CHInterpreter >> visitLiteralArrayNode: aRBLiteralArrayNode 
	
	^ aRBLiteralArrayNode contents collect: [ :each | self visitNode: each ] 
]]]

[[[
CHInterpreterTest >> testReturnAccessInstanceVariable

	receiver x: 100.
	self assert: (self executeSelector: #returnX) equals: 100
]]]

[[[
CHInterpreterTest >> testStoreInstanceVariable

	receiver x: 17.
	self executeSelector: #store100IntoX.
	self assert: receiver x equals: 100
]]]

[[[
CBasicInterpreter >> execute: anAST withReceiver: anObject

	self setSelfTo: anObject.
	^ self visitNode: anAST
]]]

[[[
CBasicInterpreter >> visitAssignmentNode: anAssignmentNode
	"| x y |
	x := y := 10.
	x
	>>> 10"
	
	| value | 
	value := (self visitNode: anAssignmentNode value).
	anAssignmentNode variable store: value with: self.
	^ value
]]]

[[[
CBasicInterpreter >> visitGlobalNode: aRBGlobalNode 

	^ self class environment at: aRBGlobalNode name ifAbsent: [ self error: aRBGlobalNode name, ' not found' ]
]]]

[[[
CBasicInterpreter >> visitInstanceVariableNode: aVariableNode

	^ self receiver instVarNamed: aVariableNode name
]]]

[[[
CBasicInterpreter >> visitLiteralArrayNode: aRBLiteralArrayNode 
	
	^ aRBLiteralArrayNode contents collect: [ :each | self visitNode: each ] 
]]]

[[[
CBasicInterpreter >> visitLiteralValueNode: aRBLiteralValueNode

	^ aRBLiteralValueNode value
]]]

[[[
CBasicInterpreter >> visitMethodBodyNode: aMethodBodyNode
	^ self visitNode: aMethodBodyNode 
]]]

[[[
CBasicInterpreter >> visitMethodNode: aMethodNode
	
	^ self visitMethodBodyNode: aMethodNode body
]]]

[[[
CBasicInterpreter >> visitReturnNode: aReturnNode

	| res |
	res := self visitNode: aReturnNode value.
	^ res
]]]

[[[
CBasicInterpreter >> visitSelfNode: aRBSelfNode 
	^ self receiver
]]]

[[[
CBasicInterpreter >> visitSuperNode: aRBSuperNode 
	^ self receiver
]]]

[[[
CBasicInterpreterTest >> testTempsAccessShouldNotEscapeMethods

	| ast result |
	ast := (CInterpretable >> #methodWithTemp) ast.
	result := self interpreter execute: ast withReceiver: CInterpretable new. 
	self assert: result equals: nil 
]]]


[[[
CBasicInterpreterTest >> testTempsShouldNotEscapeMethods

	| ast result |
	ast := (CInterpretable >> #methodWithTemp) ast.
	result := self interpreter execute: ast withReceiver: CInterpretable new. 
	self assert: result equals: nil 
]]]

[[[
CBasicInterpreterTest >> testTempsWritingShouldNotEscapeMethods

	| ast result |
	ast := (CInterpretable >> #methodCallingModifyingTemp) ast.
	result := self interpreter execute: ast withReceiver: CInterpretable new. 
	self assert: result equals: 7
]]]


[[[
BasicInterpreter1Test >> testAccessInstanceVariable

	| ast result |
	ast := (CInterpretable >> #returnX) ast.
	result := self interpreter execute: ast withReceiver: (CInterpretable new x: 100).
	self assert: result equals: 100. 
	
]]]



[[[
BasicInterpreter1Test >> testAccessXInInstance

	| ast result |
	ast := (CInterpretable >> #returnX) ast.
	result := self interpreter execute: ast withReceiver: (CInterpretable new x: 100).
	self assert: result equals: 100. 
	
]]]

